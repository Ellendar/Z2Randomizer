var e$=Object.create;var{getPrototypeOf:$8,defineProperty:D2,getOwnPropertyNames:W8}=Object;var _8=Object.prototype.hasOwnProperty;var J8=($,W,_)=>{_=$!=null?e$($8($)):{};let J=W||!$||!$.__esModule?D2(_,"default",{value:$,enumerable:!0}):_;for(let H of W8($))if(!_8.call(J,H))D2(J,H,{get:()=>$[H],enumerable:!0});return J};var H8=($,W)=>()=>(W||$((W={exports:{}}).exports,W),W.exports);var q8=($,W)=>{for(var _ in W)D2($,_,{get:W[_],enumerable:!0,configurable:!0,set:(J)=>W[_]=()=>J})};var l$=H8((x$)=>{(function(){var $={not_string:/[^s]/,not_bool:/[^t]/,not_type:/[^T]/,not_primitive:/[^v]/,number:/[diefg]/,numeric_arg:/[bcdiefguxX]/,json:/[j]/,not_json:/[^j]/,text:/^[^\x25]+/,modulo:/^\x25{2}/,placeholder:/^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,key:/^([a-z_][a-z_\d]*)/i,key_access:/^\.([a-z_][a-z_\d]*)/i,index_access:/^\[(\d+)\]/,sign:/^[+-]/};function W(Q){return J(q(Q),arguments)}function _(Q,G){return W.apply(null,[Q].concat(G||[]))}function J(Q,G){var X=1,j=Q.length,M,O="",K,A,B,k,N2,F2,S2,S0;for(K=0;K<j;K++)if(typeof Q[K]==="string")O+=Q[K];else if(typeof Q[K]==="object"){if(B=Q[K],B.keys){M=G[X];for(A=0;A<B.keys.length;A++){if(M==null)throw new Error(W('[sprintf] Cannot access property "%s" of undefined value "%s"',B.keys[A],B.keys[A-1]));M=M[B.keys[A]]}}else if(B.param_no)M=G[B.param_no];else M=G[X++];if($.not_type.test(B.type)&&$.not_primitive.test(B.type)&&M instanceof Function)M=M();if($.numeric_arg.test(B.type)&&(typeof M!=="number"&&isNaN(M)))throw new TypeError(W("[sprintf] expecting number but found %T",M));if($.number.test(B.type))S2=M>=0;switch(B.type){case"b":M=parseInt(M,10).toString(2);break;case"c":M=String.fromCharCode(parseInt(M,10));break;case"d":case"i":M=parseInt(M,10);break;case"j":M=JSON.stringify(M,null,B.width?parseInt(B.width):0);break;case"e":M=B.precision?parseFloat(M).toExponential(B.precision):parseFloat(M).toExponential();break;case"f":M=B.precision?parseFloat(M).toFixed(B.precision):parseFloat(M);break;case"g":M=B.precision?String(Number(M.toPrecision(B.precision))):parseFloat(M);break;case"o":M=(parseInt(M,10)>>>0).toString(8);break;case"s":M=String(M),M=B.precision?M.substring(0,B.precision):M;break;case"t":M=String(!!M),M=B.precision?M.substring(0,B.precision):M;break;case"T":M=Object.prototype.toString.call(M).slice(8,-1).toLowerCase(),M=B.precision?M.substring(0,B.precision):M;break;case"u":M=parseInt(M,10)>>>0;break;case"v":M=M.valueOf(),M=B.precision?M.substring(0,B.precision):M;break;case"x":M=(parseInt(M,10)>>>0).toString(16);break;case"X":M=(parseInt(M,10)>>>0).toString(16).toUpperCase();break}if($.json.test(B.type))O+=M;else{if($.number.test(B.type)&&(!S2||B.sign))S0=S2?"+":"-",M=M.toString().replace($.sign,"");else S0="";N2=B.pad_char?B.pad_char==="0"?"0":B.pad_char.charAt(1):" ",F2=B.width-(S0+M).length,k=B.width?F2>0?N2.repeat(F2):"":"",O+=B.align?S0+M+k:N2==="0"?S0+k+M:k+S0+M}}return O}var H=Object.create(null);function q(Q){if(H[Q])return H[Q];var G=Q,X,j=[],M=0;while(G){if((X=$.text.exec(G))!==null)j.push(X[0]);else if((X=$.modulo.exec(G))!==null)j.push("%");else if((X=$.placeholder.exec(G))!==null){if(X[2]){M|=1;var O=[],K=X[2],A=[];if((A=$.key.exec(K))!==null){O.push(A[1]);while((K=K.substring(A[0].length))!=="")if((A=$.key_access.exec(K))!==null)O.push(A[1]);else if((A=$.index_access.exec(K))!==null)O.push(A[1]);else throw new SyntaxError("[sprintf] failed to parse named argument key")}else throw new SyntaxError("[sprintf] failed to parse named argument key");X[2]=O}else M|=2;if(M===3)throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");j.push({placeholder:X[0],param_no:X[1],keys:X[2],sign:X[3],pad_char:X[4],align:X[5],width:X[6],precision:X[7],type:X[8]})}else throw new SyntaxError("[sprintf] unexpected placeholder");G=G.substring(X[0].length)}return H[Q]=j}if(typeof x$!=="undefined")x$.sprintf=W,x$.vsprintf=_;if(typeof window!=="undefined"){if(window.sprintf=W,window.vsprintf=_,typeof define==="function"&&define.amd)define(function(){return{sprintf:W,vsprintf:_}})}})()});function D0($,W){return 0-($^W)>>16&65535^65535}function o2($,W){return W-$>>8&65535}function A2($,W){return o2(W,$)}function A0($,W){return o2(W,$)^65535}function K2($,W){return A0(W,$)}function Q8($){let W=A2($,26)&$+65|A0($,26)&A2($,52)&$+71|A0($,52)&A2($,62)&$+-4|D0($,62)&43|D0($,63)&47;return String.fromCharCode(W)}function X8($){let W=A0($,65)&K2($,90)&$-65|A0($,97)&K2($,122)&$-71|A0($,48)&K2($,57)&$- -4|D0($,43)&62|D0($,47)&63;return W|D0(W,0)&(D0($,65)^65535)}function G8($,W,_){let J=$.length,H=Math.floor(J/3),q=J-3*H,Q=H*4;if(q)if(W)Q+=4;else Q+=2+(q>>1);let G="",X=0,j=0,M=0;while(M<J){X=(X<<8)+$[M++]&4095,j+=8;while(j>=6)j-=6,G+=_(X>>j&63)}if(j>0)G+=_(X<<6-j&63);while(G.length<Q)G+="=";return G}function M8($,W,_){let J=0;while(_>0){let H=$[J++];if(H=="=")_--;else if(!W||W.indexOf(H)<0)throw new Error("Invalid base64 padding")}if(J!==$.length)throw new Error("Invalid base64 padding length")}function j8($,W,_,J){let H=$.length,q=new Uint8Array(Math.ceil(H*3/4)),Q=0,G=0,X=0,j=0;while(j<H){let M=$[j],O=J(M.charCodeAt(0));if(O==65535){if(_&&_.indexOf(M)>=0){j++;continue}break}if(Q=(Q<<6)+O&4095,G+=6,G>=8)G-=8,q[X++]=Q>>G&255;j++}if(G>4||(Q&(1<<G)-1)!=0)throw new Error("Non-canonical base64 encoding");if(W)M8($.slice(j),_,G/2);return new Uint8Array(q.buffer,0,X)}class n2{_ignore=null;_padding=!1;_charToByte;_byteToChar;constructor($=!1,W=null,_,J){this._padding=$,this._ignore=W,this._charToByte=_,this._byteToChar=J}encode($){return G8($,this._padding,this._byteToChar)}decode($){return j8($,this._padding,this._ignore,this._charToByte)}}class l extends n2{constructor($=!0,W=null){super($,W,X8,Q8)}}class a2{table;reverse;constructor($){this.table=$;let W=[];for(let[_,J]of Object.entries($))for(let[H,q]of Object.entries(J))W[q]=[_,H];this.reverse=W}op($){let W=this.table[$];if(!W)throw new Error(`Bad mnemonic: ${$}`);return W}disasm($){let W=this.reverse[$];return W&&[...W]}argLen($){switch($){case"acc":case"imp":return 0;case"imm":case"rel":case"zpg":case"zpx":case"zpy":case"iny":case"inx":return 1;case"abs":case"abx":case"aby":case"ind":return 2}}format($,W){if($==="acc"||$==="imp")return"";if(typeof W==="number")if($==="rel"){let _=(W>127?W-256:W)+2;if(_<0)W=`*-${-_}`;else if(_>0)W=`*+${_}`;else W="*"}else if($.startsWith("zp")||$==="iny"||$==="imm")W=`$${(W&255).toString(16).padStart(2,"0")}`;else W=`$${(W&65535).toString(16).padStart(4,"0")}`;switch($){case"imm":return`#${W}`;case"rel":return W;case"zpg":return W;case"abs":return W;case"zpx":return`${W},x`;case"abx":return`${W},x`;case"zpy":return`${W},y`;case"aby":return`${W},y`;case"iny":return`(${W}),y`;case"ind":return`(${W})`;case"inx":return`(${W},x)`}}}var w0;((r2)=>r2.P02=new a2({adc:{abs:109,abx:125,aby:121,imm:105,iny:113,inx:97,zpg:101,zpx:117},and:{abs:45,abx:61,aby:57,imm:41,iny:49,inx:33,zpg:37,zpx:53},asl:{abs:14,abx:30,acc:10,imp:10,zpg:6,zpx:22},bcc:{rel:144},bcs:{rel:176},beq:{rel:240},bit:{abs:44,zpg:36},bmi:{rel:48},bne:{rel:208},bpl:{rel:16},brk:{imp:0},bvc:{rel:80},bvs:{rel:112},clc:{imp:24},cld:{imp:216},cli:{imp:88},clv:{imp:184},cmp:{abs:205,abx:221,aby:217,imm:201,iny:209,inx:193,zpg:197,zpx:213},cpx:{abs:236,imm:224,zpg:228},cpy:{abs:204,imm:192,zpg:196},dec:{abs:206,abx:222,zpg:198,zpx:214},dex:{imp:202},dey:{imp:136},eor:{abs:77,abx:93,aby:89,imm:73,iny:81,inx:65,zpg:69,zpx:85},inc:{abs:238,abx:254,zpg:230,zpx:246},inx:{imp:232},iny:{imp:200},jmp:{abs:76,ind:108},jsr:{abs:32},lda:{abs:173,abx:189,aby:185,imm:169,iny:177,inx:161,zpg:165,zpx:181},ldx:{abs:174,aby:190,imm:162,zpg:166,zpy:182},ldy:{abs:172,abx:188,imm:160,zpg:164,zpx:180},lsr:{abs:78,abx:94,acc:74,imp:74,zpg:70,zpx:86},nop:{imp:234},ora:{abs:13,abx:29,aby:25,imm:9,iny:17,inx:1,zpg:5,zpx:21},pha:{imp:72},php:{imp:8},pla:{imp:104},plp:{imp:40},rol:{abs:46,abx:62,acc:42,imp:42,zpg:38,zpx:54},ror:{abs:110,abx:126,acc:106,imp:106,zpg:102,zpx:118},rti:{imp:64},rts:{imp:96},sbc:{abs:237,abx:253,aby:249,imm:233,iny:241,inx:225,zpg:229,zpx:245},sec:{imp:56},sed:{imp:248},sei:{imp:120},sta:{abs:141,abx:157,aby:153,iny:145,inx:129,zpg:133,zpx:149},stx:{abs:142,zpg:134,zpy:150},sty:{abs:140,zpg:132,zpx:148},tax:{imp:170},tay:{imp:168},tsx:{imp:186},txa:{imp:138},txs:{imp:154},tya:{imp:152},slo:{abs:15,abx:31,aby:27,zpg:7,zpx:23,inx:3,iny:19},rla:{abs:47,abx:63,aby:59,zpg:39,zpx:55,inx:35,iny:51},sre:{abs:79,abx:95,aby:91,zpg:71,zpx:87,inx:67,iny:83},rra:{abs:111,abx:127,aby:123,zpg:103,zpx:119,inx:99,iny:115},sax:{abs:143,zpg:135,zpy:151,inx:131},lax:{abs:175,aby:191,zpg:167,zpy:183,inx:163,iny:179},dcp:{abs:207,abx:223,aby:219,zpg:199,zpx:215,inx:195,iny:211},isc:{abs:239,abx:255,aby:251,zpg:231,zpx:247,inx:227,iny:243},alr:{imm:75},arr:{imm:107},axs:{imm:203},tas:{aby:155},shy:{abx:156},shx:{aby:158},ahx:{aby:159,iny:147},anc:{imm:43},las:{aby:187}}))(w0||={});var R={};q8(R,{void:()=>n8,util:()=>D,unknown:()=>i8,union:()=>t8,undefined:()=>c8,tuple:()=>W4,transformer:()=>Y4,symbol:()=>u8,string:()=>q$,strictObject:()=>s8,setErrorMap:()=>w8,set:()=>H4,record:()=>_4,quotelessJson:()=>Y8,promise:()=>j4,preprocess:()=>R4,pipeline:()=>V4,ostring:()=>B4,optional:()=>z4,onumber:()=>E4,oboolean:()=>U4,objectUtil:()=>v2,object:()=>a8,number:()=>Q$,nullable:()=>w4,null:()=>d8,never:()=>o8,nativeEnum:()=>M4,nan:()=>m8,map:()=>J4,makeIssue:()=>i0,literal:()=>X4,lazy:()=>Q4,late:()=>y8,isValid:()=>q0,isDirty:()=>G2,isAsync:()=>v0,isAborted:()=>X2,intersection:()=>$4,instanceof:()=>k8,getParsedType:()=>n,getErrorMap:()=>K0,function:()=>q4,enum:()=>G4,effect:()=>Y4,discriminatedUnion:()=>e8,defaultErrorMap:()=>W0,datetimeRegex:()=>_$,date:()=>l8,custom:()=>H$,coerce:()=>L4,boolean:()=>X$,bigint:()=>x8,array:()=>r8,any:()=>p8,addIssueToContext:()=>w,ZodVoid:()=>n0,ZodUnknown:()=>Q0,ZodUnion:()=>T0,ZodUndefined:()=>I0,ZodType:()=>S,ZodTuple:()=>a,ZodTransformer:()=>i,ZodSymbol:()=>o0,ZodString:()=>u,ZodSet:()=>E0,ZodSchema:()=>S,ZodRecord:()=>r0,ZodReadonly:()=>x0,ZodPromise:()=>U0,ZodPipeline:()=>t0,ZodParsedType:()=>z,ZodOptional:()=>d,ZodObject:()=>b,ZodNumber:()=>X0,ZodNullable:()=>J0,ZodNull:()=>f0,ZodNever:()=>r,ZodNativeEnum:()=>y0,ZodNaN:()=>s0,ZodMap:()=>a0,ZodLiteral:()=>Z0,ZodLazy:()=>g0,ZodIssueCode:()=>Y,ZodIntersection:()=>h0,ZodFunction:()=>C0,ZodFirstPartyTypeKind:()=>L,ZodError:()=>m,ZodEnum:()=>M0,ZodEffects:()=>i,ZodDiscriminatedUnion:()=>M2,ZodDefault:()=>k0,ZodDate:()=>V0,ZodCatch:()=>m0,ZodBranded:()=>j2,ZodBoolean:()=>P0,ZodBigInt:()=>G0,ZodArray:()=>c,ZodAny:()=>B0,Schema:()=>S,ParseStatus:()=>I,OK:()=>h,NEVER:()=>O4,INVALID:()=>U,EMPTY_PATH:()=>R8,DIRTY:()=>R0,BRAND:()=>Z8});var D;(function($){$.assertEqual=(H)=>{};function W(H){}$.assertIs=W;function _(H){throw new Error}$.assertNever=_,$.arrayToEnum=(H)=>{let q={};for(let Q of H)q[Q]=Q;return q},$.getValidEnumValues=(H)=>{let q=$.objectKeys(H).filter((G)=>typeof H[H[G]]!=="number"),Q={};for(let G of q)Q[G]=H[G];return $.objectValues(Q)},$.objectValues=(H)=>{return $.objectKeys(H).map(function(q){return H[q]})},$.objectKeys=typeof Object.keys==="function"?(H)=>Object.keys(H):(H)=>{let q=[];for(let Q in H)if(Object.prototype.hasOwnProperty.call(H,Q))q.push(Q);return q},$.find=(H,q)=>{for(let Q of H)if(q(Q))return Q;return},$.isInteger=typeof Number.isInteger==="function"?(H)=>Number.isInteger(H):(H)=>typeof H==="number"&&Number.isFinite(H)&&Math.floor(H)===H;function J(H,q=" | "){return H.map((Q)=>typeof Q==="string"?`'${Q}'`:Q).join(q)}$.joinValues=J,$.jsonStringifyReplacer=(H,q)=>{if(typeof q==="bigint")return q.toString();return q}})(D||(D={}));var v2;(function($){$.mergeShapes=(W,_)=>{return{...W,..._}}})(v2||(v2={}));var z=D.arrayToEnum(["string","nan","number","integer","float","boolean","date","bigint","symbol","function","undefined","null","array","object","unknown","promise","void","never","map","set"]),n=($)=>{switch(typeof $){case"undefined":return z.undefined;case"string":return z.string;case"number":return Number.isNaN($)?z.nan:z.number;case"boolean":return z.boolean;case"function":return z.function;case"bigint":return z.bigint;case"symbol":return z.symbol;case"object":if(Array.isArray($))return z.array;if($===null)return z.null;if($.then&&typeof $.then==="function"&&$.catch&&typeof $.catch==="function")return z.promise;if(typeof Map!=="undefined"&&$ instanceof Map)return z.map;if(typeof Set!=="undefined"&&$ instanceof Set)return z.set;if(typeof Date!=="undefined"&&$ instanceof Date)return z.date;return z.object;default:return z.unknown}};var Y=D.arrayToEnum(["invalid_type","invalid_literal","custom","invalid_union","invalid_union_discriminator","invalid_enum_value","unrecognized_keys","invalid_arguments","invalid_return_type","invalid_date","invalid_string","too_small","too_big","invalid_intersection_types","not_multiple_of","not_finite"]),Y8=($)=>{return JSON.stringify($,null,2).replace(/"([^"]+)":/g,"$1:")};class m extends Error{get errors(){return this.issues}constructor($){super();this.issues=[],this.addIssue=(_)=>{this.issues=[...this.issues,_]},this.addIssues=(_=[])=>{this.issues=[...this.issues,..._]};let W=new.target.prototype;if(Object.setPrototypeOf)Object.setPrototypeOf(this,W);else this.__proto__=W;this.name="ZodError",this.issues=$}format($){let W=$||function(H){return H.message},_={_errors:[]},J=(H)=>{for(let q of H.issues)if(q.code==="invalid_union")q.unionErrors.map(J);else if(q.code==="invalid_return_type")J(q.returnTypeError);else if(q.code==="invalid_arguments")J(q.argumentsError);else if(q.path.length===0)_._errors.push(W(q));else{let Q=_,G=0;while(G<q.path.length){let X=q.path[G];if(G!==q.path.length-1)Q[X]=Q[X]||{_errors:[]};else Q[X]=Q[X]||{_errors:[]},Q[X]._errors.push(W(q));Q=Q[X],G++}}};return J(this),_}static assert($){if(!($ instanceof m))throw new Error(`Not a ZodError: ${$}`)}toString(){return this.message}get message(){return JSON.stringify(this.issues,D.jsonStringifyReplacer,2)}get isEmpty(){return this.issues.length===0}flatten($=(W)=>W.message){let W={},_=[];for(let J of this.issues)if(J.path.length>0){let H=J.path[0];W[H]=W[H]||[],W[H].push($(J))}else _.push($(J));return{formErrors:_,fieldErrors:W}}get formErrors(){return this.flatten()}}m.create=($)=>{return new m($)};var z8=($,W)=>{let _;switch($.code){case Y.invalid_type:if($.received===z.undefined)_="Required";else _=`Expected ${$.expected}, received ${$.received}`;break;case Y.invalid_literal:_=`Invalid literal value, expected ${JSON.stringify($.expected,D.jsonStringifyReplacer)}`;break;case Y.unrecognized_keys:_=`Unrecognized key(s) in object: ${D.joinValues($.keys,", ")}`;break;case Y.invalid_union:_="Invalid input";break;case Y.invalid_union_discriminator:_=`Invalid discriminator value. Expected ${D.joinValues($.options)}`;break;case Y.invalid_enum_value:_=`Invalid enum value. Expected ${D.joinValues($.options)}, received '${$.received}'`;break;case Y.invalid_arguments:_="Invalid function arguments";break;case Y.invalid_return_type:_="Invalid function return type";break;case Y.invalid_date:_="Invalid date";break;case Y.invalid_string:if(typeof $.validation==="object")if("includes"in $.validation){if(_=`Invalid input: must include "${$.validation.includes}"`,typeof $.validation.position==="number")_=`${_} at one or more positions greater than or equal to ${$.validation.position}`}else if("startsWith"in $.validation)_=`Invalid input: must start with "${$.validation.startsWith}"`;else if("endsWith"in $.validation)_=`Invalid input: must end with "${$.validation.endsWith}"`;else D.assertNever($.validation);else if($.validation!=="regex")_=`Invalid ${$.validation}`;else _="Invalid";break;case Y.too_small:if($.type==="array")_=`Array must contain ${$.exact?"exactly":$.inclusive?"at least":"more than"} ${$.minimum} element(s)`;else if($.type==="string")_=`String must contain ${$.exact?"exactly":$.inclusive?"at least":"over"} ${$.minimum} character(s)`;else if($.type==="number")_=`Number must be ${$.exact?"exactly equal to ":$.inclusive?"greater than or equal to ":"greater than "}${$.minimum}`;else if($.type==="bigint")_=`Number must be ${$.exact?"exactly equal to ":$.inclusive?"greater than or equal to ":"greater than "}${$.minimum}`;else if($.type==="date")_=`Date must be ${$.exact?"exactly equal to ":$.inclusive?"greater than or equal to ":"greater than "}${new Date(Number($.minimum))}`;else _="Invalid input";break;case Y.too_big:if($.type==="array")_=`Array must contain ${$.exact?"exactly":$.inclusive?"at most":"less than"} ${$.maximum} element(s)`;else if($.type==="string")_=`String must contain ${$.exact?"exactly":$.inclusive?"at most":"under"} ${$.maximum} character(s)`;else if($.type==="number")_=`Number must be ${$.exact?"exactly":$.inclusive?"less than or equal to":"less than"} ${$.maximum}`;else if($.type==="bigint")_=`BigInt must be ${$.exact?"exactly":$.inclusive?"less than or equal to":"less than"} ${$.maximum}`;else if($.type==="date")_=`Date must be ${$.exact?"exactly":$.inclusive?"smaller than or equal to":"smaller than"} ${new Date(Number($.maximum))}`;else _="Invalid input";break;case Y.custom:_="Invalid input";break;case Y.invalid_intersection_types:_="Intersection results could not be merged";break;case Y.not_multiple_of:_=`Number must be a multiple of ${$.multipleOf}`;break;case Y.not_finite:_="Number must be finite";break;default:_=W.defaultError,D.assertNever($)}return{message:_}},W0=z8;var s2=W0;function w8($){s2=$}function K0(){return s2}var i0=($)=>{let{data:W,path:_,errorMaps:J,issueData:H}=$,q=[..._,...H.path||[]],Q={...H,path:q};if(H.message!==void 0)return{...H,path:q,message:H.message};let G="",X=J.filter((j)=>!!j).slice().reverse();for(let j of X)G=j(Q,{data:W,defaultError:G}).message;return{...H,path:q,message:G}},R8=[];function w($,W){let _=K0(),J=i0({issueData:W,data:$.data,path:$.path,errorMaps:[$.common.contextualErrorMap,$.schemaErrorMap,_,_===W0?void 0:W0].filter((H)=>!!H)});$.common.issues.push(J)}class I{constructor(){this.value="valid"}dirty(){if(this.value==="valid")this.value="dirty"}abort(){if(this.value!=="aborted")this.value="aborted"}static mergeArray($,W){let _=[];for(let J of W){if(J.status==="aborted")return U;if(J.status==="dirty")$.dirty();_.push(J.value)}return{status:$.value,value:_}}static async mergeObjectAsync($,W){let _=[];for(let J of W){let H=await J.key,q=await J.value;_.push({key:H,value:q})}return I.mergeObjectSync($,_)}static mergeObjectSync($,W){let _={};for(let J of W){let{key:H,value:q}=J;if(H.status==="aborted")return U;if(q.status==="aborted")return U;if(H.status==="dirty")$.dirty();if(q.status==="dirty")$.dirty();if(H.value!=="__proto__"&&(typeof q.value!=="undefined"||J.alwaysSet))_[H.value]=q.value}return{status:$.value,value:_}}}var U=Object.freeze({status:"aborted"}),R0=($)=>({status:"dirty",value:$}),h=($)=>({status:"valid",value:$}),X2=($)=>$.status==="aborted",G2=($)=>$.status==="dirty",q0=($)=>$.status==="valid",v0=($)=>typeof Promise!=="undefined"&&$ instanceof Promise;var V;(function($){$.errToObj=(W)=>typeof W==="string"?{message:W}:W||{},$.toString=(W)=>typeof W==="string"?W:W?.message})(V||(V={}));class p{constructor($,W,_,J){this._cachedPath=[],this.parent=$,this.data=W,this._path=_,this._key=J}get path(){if(!this._cachedPath.length)if(Array.isArray(this._key))this._cachedPath.push(...this._path,...this._key);else this._cachedPath.push(...this._path,this._key);return this._cachedPath}}var t2=($,W)=>{if(q0(W))return{success:!0,data:W.value};else{if(!$.common.issues.length)throw new Error("Validation failed but no issues detected.");return{success:!1,get error(){if(this._error)return this._error;let _=new m($.common.issues);return this._error=_,this._error}}}};function N($){if(!$)return{};let{errorMap:W,invalid_type_error:_,required_error:J,description:H}=$;if(W&&(_||J))throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);if(W)return{errorMap:W,description:H};return{errorMap:(Q,G)=>{let{message:X}=$;if(Q.code==="invalid_enum_value")return{message:X??G.defaultError};if(typeof G.data==="undefined")return{message:X??J??G.defaultError};if(Q.code!=="invalid_type")return{message:G.defaultError};return{message:X??_??G.defaultError}},description:H}}class S{get description(){return this._def.description}_getType($){return n($.data)}_getOrReturnCtx($,W){return W||{common:$.parent.common,data:$.data,parsedType:n($.data),schemaErrorMap:this._def.errorMap,path:$.path,parent:$.parent}}_processInputParams($){return{status:new I,ctx:{common:$.parent.common,data:$.data,parsedType:n($.data),schemaErrorMap:this._def.errorMap,path:$.path,parent:$.parent}}}_parseSync($){let W=this._parse($);if(v0(W))throw new Error("Synchronous parse encountered promise.");return W}_parseAsync($){let W=this._parse($);return Promise.resolve(W)}parse($,W){let _=this.safeParse($,W);if(_.success)return _.data;throw _.error}safeParse($,W){let _={common:{issues:[],async:W?.async??!1,contextualErrorMap:W?.errorMap},path:W?.path||[],schemaErrorMap:this._def.errorMap,parent:null,data:$,parsedType:n($)},J=this._parseSync({data:$,path:_.path,parent:_});return t2(_,J)}"~validate"($){let W={common:{issues:[],async:!!this["~standard"].async},path:[],schemaErrorMap:this._def.errorMap,parent:null,data:$,parsedType:n($)};if(!this["~standard"].async)try{let _=this._parseSync({data:$,path:[],parent:W});return q0(_)?{value:_.value}:{issues:W.common.issues}}catch(_){if(_?.message?.toLowerCase()?.includes("encountered"))this["~standard"].async=!0;W.common={issues:[],async:!0}}return this._parseAsync({data:$,path:[],parent:W}).then((_)=>q0(_)?{value:_.value}:{issues:W.common.issues})}async parseAsync($,W){let _=await this.safeParseAsync($,W);if(_.success)return _.data;throw _.error}async safeParseAsync($,W){let _={common:{issues:[],contextualErrorMap:W?.errorMap,async:!0},path:W?.path||[],schemaErrorMap:this._def.errorMap,parent:null,data:$,parsedType:n($)},J=this._parse({data:$,path:_.path,parent:_}),H=await(v0(J)?J:Promise.resolve(J));return t2(_,H)}refine($,W){let _=(J)=>{if(typeof W==="string"||typeof W==="undefined")return{message:W};else if(typeof W==="function")return W(J);else return W};return this._refinement((J,H)=>{let q=$(J),Q=()=>H.addIssue({code:Y.custom,..._(J)});if(typeof Promise!=="undefined"&&q instanceof Promise)return q.then((G)=>{if(!G)return Q(),!1;else return!0});if(!q)return Q(),!1;else return!0})}refinement($,W){return this._refinement((_,J)=>{if(!$(_))return J.addIssue(typeof W==="function"?W(_,J):W),!1;else return!0})}_refinement($){return new i({schema:this,typeName:L.ZodEffects,effect:{type:"refinement",refinement:$}})}superRefine($){return this._refinement($)}constructor($){this.spa=this.safeParseAsync,this._def=$,this.parse=this.parse.bind(this),this.safeParse=this.safeParse.bind(this),this.parseAsync=this.parseAsync.bind(this),this.safeParseAsync=this.safeParseAsync.bind(this),this.spa=this.spa.bind(this),this.refine=this.refine.bind(this),this.refinement=this.refinement.bind(this),this.superRefine=this.superRefine.bind(this),this.optional=this.optional.bind(this),this.nullable=this.nullable.bind(this),this.nullish=this.nullish.bind(this),this.array=this.array.bind(this),this.promise=this.promise.bind(this),this.or=this.or.bind(this),this.and=this.and.bind(this),this.transform=this.transform.bind(this),this.brand=this.brand.bind(this),this.default=this.default.bind(this),this.catch=this.catch.bind(this),this.describe=this.describe.bind(this),this.pipe=this.pipe.bind(this),this.readonly=this.readonly.bind(this),this.isNullable=this.isNullable.bind(this),this.isOptional=this.isOptional.bind(this),this["~standard"]={version:1,vendor:"zod",validate:(W)=>this["~validate"](W)}}optional(){return d.create(this,this._def)}nullable(){return J0.create(this,this._def)}nullish(){return this.nullable().optional()}array(){return c.create(this)}promise(){return U0.create(this,this._def)}or($){return T0.create([this,$],this._def)}and($){return h0.create(this,$,this._def)}transform($){return new i({...N(this._def),schema:this,typeName:L.ZodEffects,effect:{type:"transform",transform:$}})}default($){let W=typeof $==="function"?$:()=>$;return new k0({...N(this._def),innerType:this,defaultValue:W,typeName:L.ZodDefault})}brand(){return new j2({typeName:L.ZodBranded,type:this,...N(this._def)})}catch($){let W=typeof $==="function"?$:()=>$;return new m0({...N(this._def),innerType:this,catchValue:W,typeName:L.ZodCatch})}describe($){return new this.constructor({...this._def,description:$})}pipe($){return t0.create(this,$)}readonly(){return x0.create(this)}isOptional(){return this.safeParse(void 0).success}isNullable(){return this.safeParse(null).success}}var V8=/^c[^\s-]{8,}$/i,B8=/^[0-9a-z]+$/,E8=/^[0-9A-HJKMNP-TV-Z]{26}$/i,U8=/^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,L8=/^[a-z0-9_-]{21}$/i,O8=/^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,N8=/^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,F8=/^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,S8="^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",b2,D8=/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,A8=/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,K8=/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/,v8=/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,b8=/^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,C8=/^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,$$="((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",P8=new RegExp(`^${$$}$`);function W$($){let W="[0-5]\\d";if($.precision)W=`${W}\\.\\d{${$.precision}}`;else if($.precision==null)W=`${W}(\\.\\d+)?`;let _=$.precision?"+":"?";return`([01]\\d|2[0-3]):[0-5]\\d(:${W})${_}`}function I8($){return new RegExp(`^${W$($)}$`)}function _$($){let W=`${$$}T${W$($)}`,_=[];if(_.push($.local?"Z?":"Z"),$.offset)_.push("([+-]\\d{2}:?\\d{2})");return W=`${W}(${_.join("|")})`,new RegExp(`^${W}$`)}function f8($,W){if((W==="v4"||!W)&&D8.test($))return!0;if((W==="v6"||!W)&&K8.test($))return!0;return!1}function T8($,W){if(!O8.test($))return!1;try{let[_]=$.split(".");if(!_)return!1;let J=_.replace(/-/g,"+").replace(/_/g,"/").padEnd(_.length+(4-_.length%4)%4,"="),H=JSON.parse(atob(J));if(typeof H!=="object"||H===null)return!1;if("typ"in H&&H?.typ!=="JWT")return!1;if(!H.alg)return!1;if(W&&H.alg!==W)return!1;return!0}catch{return!1}}function h8($,W){if((W==="v4"||!W)&&A8.test($))return!0;if((W==="v6"||!W)&&v8.test($))return!0;return!1}class u extends S{_parse($){if(this._def.coerce)$.data=String($.data);if(this._getType($)!==z.string){let H=this._getOrReturnCtx($);return w(H,{code:Y.invalid_type,expected:z.string,received:H.parsedType}),U}let _=new I,J=void 0;for(let H of this._def.checks)if(H.kind==="min"){if($.data.length<H.value)J=this._getOrReturnCtx($,J),w(J,{code:Y.too_small,minimum:H.value,type:"string",inclusive:!0,exact:!1,message:H.message}),_.dirty()}else if(H.kind==="max"){if($.data.length>H.value)J=this._getOrReturnCtx($,J),w(J,{code:Y.too_big,maximum:H.value,type:"string",inclusive:!0,exact:!1,message:H.message}),_.dirty()}else if(H.kind==="length"){let q=$.data.length>H.value,Q=$.data.length<H.value;if(q||Q){if(J=this._getOrReturnCtx($,J),q)w(J,{code:Y.too_big,maximum:H.value,type:"string",inclusive:!0,exact:!0,message:H.message});else if(Q)w(J,{code:Y.too_small,minimum:H.value,type:"string",inclusive:!0,exact:!0,message:H.message});_.dirty()}}else if(H.kind==="email"){if(!F8.test($.data))J=this._getOrReturnCtx($,J),w(J,{validation:"email",code:Y.invalid_string,message:H.message}),_.dirty()}else if(H.kind==="emoji"){if(!b2)b2=new RegExp(S8,"u");if(!b2.test($.data))J=this._getOrReturnCtx($,J),w(J,{validation:"emoji",code:Y.invalid_string,message:H.message}),_.dirty()}else if(H.kind==="uuid"){if(!U8.test($.data))J=this._getOrReturnCtx($,J),w(J,{validation:"uuid",code:Y.invalid_string,message:H.message}),_.dirty()}else if(H.kind==="nanoid"){if(!L8.test($.data))J=this._getOrReturnCtx($,J),w(J,{validation:"nanoid",code:Y.invalid_string,message:H.message}),_.dirty()}else if(H.kind==="cuid"){if(!V8.test($.data))J=this._getOrReturnCtx($,J),w(J,{validation:"cuid",code:Y.invalid_string,message:H.message}),_.dirty()}else if(H.kind==="cuid2"){if(!B8.test($.data))J=this._getOrReturnCtx($,J),w(J,{validation:"cuid2",code:Y.invalid_string,message:H.message}),_.dirty()}else if(H.kind==="ulid"){if(!E8.test($.data))J=this._getOrReturnCtx($,J),w(J,{validation:"ulid",code:Y.invalid_string,message:H.message}),_.dirty()}else if(H.kind==="url")try{new URL($.data)}catch{J=this._getOrReturnCtx($,J),w(J,{validation:"url",code:Y.invalid_string,message:H.message}),_.dirty()}else if(H.kind==="regex"){if(H.regex.lastIndex=0,!H.regex.test($.data))J=this._getOrReturnCtx($,J),w(J,{validation:"regex",code:Y.invalid_string,message:H.message}),_.dirty()}else if(H.kind==="trim")$.data=$.data.trim();else if(H.kind==="includes"){if(!$.data.includes(H.value,H.position))J=this._getOrReturnCtx($,J),w(J,{code:Y.invalid_string,validation:{includes:H.value,position:H.position},message:H.message}),_.dirty()}else if(H.kind==="toLowerCase")$.data=$.data.toLowerCase();else if(H.kind==="toUpperCase")$.data=$.data.toUpperCase();else if(H.kind==="startsWith"){if(!$.data.startsWith(H.value))J=this._getOrReturnCtx($,J),w(J,{code:Y.invalid_string,validation:{startsWith:H.value},message:H.message}),_.dirty()}else if(H.kind==="endsWith"){if(!$.data.endsWith(H.value))J=this._getOrReturnCtx($,J),w(J,{code:Y.invalid_string,validation:{endsWith:H.value},message:H.message}),_.dirty()}else if(H.kind==="datetime"){if(!_$(H).test($.data))J=this._getOrReturnCtx($,J),w(J,{code:Y.invalid_string,validation:"datetime",message:H.message}),_.dirty()}else if(H.kind==="date"){if(!P8.test($.data))J=this._getOrReturnCtx($,J),w(J,{code:Y.invalid_string,validation:"date",message:H.message}),_.dirty()}else if(H.kind==="time"){if(!I8(H).test($.data))J=this._getOrReturnCtx($,J),w(J,{code:Y.invalid_string,validation:"time",message:H.message}),_.dirty()}else if(H.kind==="duration"){if(!N8.test($.data))J=this._getOrReturnCtx($,J),w(J,{validation:"duration",code:Y.invalid_string,message:H.message}),_.dirty()}else if(H.kind==="ip"){if(!f8($.data,H.version))J=this._getOrReturnCtx($,J),w(J,{validation:"ip",code:Y.invalid_string,message:H.message}),_.dirty()}else if(H.kind==="jwt"){if(!T8($.data,H.alg))J=this._getOrReturnCtx($,J),w(J,{validation:"jwt",code:Y.invalid_string,message:H.message}),_.dirty()}else if(H.kind==="cidr"){if(!h8($.data,H.version))J=this._getOrReturnCtx($,J),w(J,{validation:"cidr",code:Y.invalid_string,message:H.message}),_.dirty()}else if(H.kind==="base64"){if(!b8.test($.data))J=this._getOrReturnCtx($,J),w(J,{validation:"base64",code:Y.invalid_string,message:H.message}),_.dirty()}else if(H.kind==="base64url"){if(!C8.test($.data))J=this._getOrReturnCtx($,J),w(J,{validation:"base64url",code:Y.invalid_string,message:H.message}),_.dirty()}else D.assertNever(H);return{status:_.value,value:$.data}}_regex($,W,_){return this.refinement((J)=>$.test(J),{validation:W,code:Y.invalid_string,...V.errToObj(_)})}_addCheck($){return new u({...this._def,checks:[...this._def.checks,$]})}email($){return this._addCheck({kind:"email",...V.errToObj($)})}url($){return this._addCheck({kind:"url",...V.errToObj($)})}emoji($){return this._addCheck({kind:"emoji",...V.errToObj($)})}uuid($){return this._addCheck({kind:"uuid",...V.errToObj($)})}nanoid($){return this._addCheck({kind:"nanoid",...V.errToObj($)})}cuid($){return this._addCheck({kind:"cuid",...V.errToObj($)})}cuid2($){return this._addCheck({kind:"cuid2",...V.errToObj($)})}ulid($){return this._addCheck({kind:"ulid",...V.errToObj($)})}base64($){return this._addCheck({kind:"base64",...V.errToObj($)})}base64url($){return this._addCheck({kind:"base64url",...V.errToObj($)})}jwt($){return this._addCheck({kind:"jwt",...V.errToObj($)})}ip($){return this._addCheck({kind:"ip",...V.errToObj($)})}cidr($){return this._addCheck({kind:"cidr",...V.errToObj($)})}datetime($){if(typeof $==="string")return this._addCheck({kind:"datetime",precision:null,offset:!1,local:!1,message:$});return this._addCheck({kind:"datetime",precision:typeof $?.precision==="undefined"?null:$?.precision,offset:$?.offset??!1,local:$?.local??!1,...V.errToObj($?.message)})}date($){return this._addCheck({kind:"date",message:$})}time($){if(typeof $==="string")return this._addCheck({kind:"time",precision:null,message:$});return this._addCheck({kind:"time",precision:typeof $?.precision==="undefined"?null:$?.precision,...V.errToObj($?.message)})}duration($){return this._addCheck({kind:"duration",...V.errToObj($)})}regex($,W){return this._addCheck({kind:"regex",regex:$,...V.errToObj(W)})}includes($,W){return this._addCheck({kind:"includes",value:$,position:W?.position,...V.errToObj(W?.message)})}startsWith($,W){return this._addCheck({kind:"startsWith",value:$,...V.errToObj(W)})}endsWith($,W){return this._addCheck({kind:"endsWith",value:$,...V.errToObj(W)})}min($,W){return this._addCheck({kind:"min",value:$,...V.errToObj(W)})}max($,W){return this._addCheck({kind:"max",value:$,...V.errToObj(W)})}length($,W){return this._addCheck({kind:"length",value:$,...V.errToObj(W)})}nonempty($){return this.min(1,V.errToObj($))}trim(){return new u({...this._def,checks:[...this._def.checks,{kind:"trim"}]})}toLowerCase(){return new u({...this._def,checks:[...this._def.checks,{kind:"toLowerCase"}]})}toUpperCase(){return new u({...this._def,checks:[...this._def.checks,{kind:"toUpperCase"}]})}get isDatetime(){return!!this._def.checks.find(($)=>$.kind==="datetime")}get isDate(){return!!this._def.checks.find(($)=>$.kind==="date")}get isTime(){return!!this._def.checks.find(($)=>$.kind==="time")}get isDuration(){return!!this._def.checks.find(($)=>$.kind==="duration")}get isEmail(){return!!this._def.checks.find(($)=>$.kind==="email")}get isURL(){return!!this._def.checks.find(($)=>$.kind==="url")}get isEmoji(){return!!this._def.checks.find(($)=>$.kind==="emoji")}get isUUID(){return!!this._def.checks.find(($)=>$.kind==="uuid")}get isNANOID(){return!!this._def.checks.find(($)=>$.kind==="nanoid")}get isCUID(){return!!this._def.checks.find(($)=>$.kind==="cuid")}get isCUID2(){return!!this._def.checks.find(($)=>$.kind==="cuid2")}get isULID(){return!!this._def.checks.find(($)=>$.kind==="ulid")}get isIP(){return!!this._def.checks.find(($)=>$.kind==="ip")}get isCIDR(){return!!this._def.checks.find(($)=>$.kind==="cidr")}get isBase64(){return!!this._def.checks.find(($)=>$.kind==="base64")}get isBase64url(){return!!this._def.checks.find(($)=>$.kind==="base64url")}get minLength(){let $=null;for(let W of this._def.checks)if(W.kind==="min"){if($===null||W.value>$)$=W.value}return $}get maxLength(){let $=null;for(let W of this._def.checks)if(W.kind==="max"){if($===null||W.value<$)$=W.value}return $}}u.create=($)=>{return new u({checks:[],typeName:L.ZodString,coerce:$?.coerce??!1,...N($)})};function g8($,W){let _=($.toString().split(".")[1]||"").length,J=(W.toString().split(".")[1]||"").length,H=_>J?_:J,q=Number.parseInt($.toFixed(H).replace(".","")),Q=Number.parseInt(W.toFixed(H).replace(".",""));return q%Q/10**H}class X0 extends S{constructor(){super(...arguments);this.min=this.gte,this.max=this.lte,this.step=this.multipleOf}_parse($){if(this._def.coerce)$.data=Number($.data);if(this._getType($)!==z.number){let H=this._getOrReturnCtx($);return w(H,{code:Y.invalid_type,expected:z.number,received:H.parsedType}),U}let _=void 0,J=new I;for(let H of this._def.checks)if(H.kind==="int"){if(!D.isInteger($.data))_=this._getOrReturnCtx($,_),w(_,{code:Y.invalid_type,expected:"integer",received:"float",message:H.message}),J.dirty()}else if(H.kind==="min"){if(H.inclusive?$.data<H.value:$.data<=H.value)_=this._getOrReturnCtx($,_),w(_,{code:Y.too_small,minimum:H.value,type:"number",inclusive:H.inclusive,exact:!1,message:H.message}),J.dirty()}else if(H.kind==="max"){if(H.inclusive?$.data>H.value:$.data>=H.value)_=this._getOrReturnCtx($,_),w(_,{code:Y.too_big,maximum:H.value,type:"number",inclusive:H.inclusive,exact:!1,message:H.message}),J.dirty()}else if(H.kind==="multipleOf"){if(g8($.data,H.value)!==0)_=this._getOrReturnCtx($,_),w(_,{code:Y.not_multiple_of,multipleOf:H.value,message:H.message}),J.dirty()}else if(H.kind==="finite"){if(!Number.isFinite($.data))_=this._getOrReturnCtx($,_),w(_,{code:Y.not_finite,message:H.message}),J.dirty()}else D.assertNever(H);return{status:J.value,value:$.data}}gte($,W){return this.setLimit("min",$,!0,V.toString(W))}gt($,W){return this.setLimit("min",$,!1,V.toString(W))}lte($,W){return this.setLimit("max",$,!0,V.toString(W))}lt($,W){return this.setLimit("max",$,!1,V.toString(W))}setLimit($,W,_,J){return new X0({...this._def,checks:[...this._def.checks,{kind:$,value:W,inclusive:_,message:V.toString(J)}]})}_addCheck($){return new X0({...this._def,checks:[...this._def.checks,$]})}int($){return this._addCheck({kind:"int",message:V.toString($)})}positive($){return this._addCheck({kind:"min",value:0,inclusive:!1,message:V.toString($)})}negative($){return this._addCheck({kind:"max",value:0,inclusive:!1,message:V.toString($)})}nonpositive($){return this._addCheck({kind:"max",value:0,inclusive:!0,message:V.toString($)})}nonnegative($){return this._addCheck({kind:"min",value:0,inclusive:!0,message:V.toString($)})}multipleOf($,W){return this._addCheck({kind:"multipleOf",value:$,message:V.toString(W)})}finite($){return this._addCheck({kind:"finite",message:V.toString($)})}safe($){return this._addCheck({kind:"min",inclusive:!0,value:Number.MIN_SAFE_INTEGER,message:V.toString($)})._addCheck({kind:"max",inclusive:!0,value:Number.MAX_SAFE_INTEGER,message:V.toString($)})}get minValue(){let $=null;for(let W of this._def.checks)if(W.kind==="min"){if($===null||W.value>$)$=W.value}return $}get maxValue(){let $=null;for(let W of this._def.checks)if(W.kind==="max"){if($===null||W.value<$)$=W.value}return $}get isInt(){return!!this._def.checks.find(($)=>$.kind==="int"||$.kind==="multipleOf"&&D.isInteger($.value))}get isFinite(){let $=null,W=null;for(let _ of this._def.checks)if(_.kind==="finite"||_.kind==="int"||_.kind==="multipleOf")return!0;else if(_.kind==="min"){if(W===null||_.value>W)W=_.value}else if(_.kind==="max"){if($===null||_.value<$)$=_.value}return Number.isFinite(W)&&Number.isFinite($)}}X0.create=($)=>{return new X0({checks:[],typeName:L.ZodNumber,coerce:$?.coerce||!1,...N($)})};class G0 extends S{constructor(){super(...arguments);this.min=this.gte,this.max=this.lte}_parse($){if(this._def.coerce)try{$.data=BigInt($.data)}catch{return this._getInvalidInput($)}if(this._getType($)!==z.bigint)return this._getInvalidInput($);let _=void 0,J=new I;for(let H of this._def.checks)if(H.kind==="min"){if(H.inclusive?$.data<H.value:$.data<=H.value)_=this._getOrReturnCtx($,_),w(_,{code:Y.too_small,type:"bigint",minimum:H.value,inclusive:H.inclusive,message:H.message}),J.dirty()}else if(H.kind==="max"){if(H.inclusive?$.data>H.value:$.data>=H.value)_=this._getOrReturnCtx($,_),w(_,{code:Y.too_big,type:"bigint",maximum:H.value,inclusive:H.inclusive,message:H.message}),J.dirty()}else if(H.kind==="multipleOf"){if($.data%H.value!==BigInt(0))_=this._getOrReturnCtx($,_),w(_,{code:Y.not_multiple_of,multipleOf:H.value,message:H.message}),J.dirty()}else D.assertNever(H);return{status:J.value,value:$.data}}_getInvalidInput($){let W=this._getOrReturnCtx($);return w(W,{code:Y.invalid_type,expected:z.bigint,received:W.parsedType}),U}gte($,W){return this.setLimit("min",$,!0,V.toString(W))}gt($,W){return this.setLimit("min",$,!1,V.toString(W))}lte($,W){return this.setLimit("max",$,!0,V.toString(W))}lt($,W){return this.setLimit("max",$,!1,V.toString(W))}setLimit($,W,_,J){return new G0({...this._def,checks:[...this._def.checks,{kind:$,value:W,inclusive:_,message:V.toString(J)}]})}_addCheck($){return new G0({...this._def,checks:[...this._def.checks,$]})}positive($){return this._addCheck({kind:"min",value:BigInt(0),inclusive:!1,message:V.toString($)})}negative($){return this._addCheck({kind:"max",value:BigInt(0),inclusive:!1,message:V.toString($)})}nonpositive($){return this._addCheck({kind:"max",value:BigInt(0),inclusive:!0,message:V.toString($)})}nonnegative($){return this._addCheck({kind:"min",value:BigInt(0),inclusive:!0,message:V.toString($)})}multipleOf($,W){return this._addCheck({kind:"multipleOf",value:$,message:V.toString(W)})}get minValue(){let $=null;for(let W of this._def.checks)if(W.kind==="min"){if($===null||W.value>$)$=W.value}return $}get maxValue(){let $=null;for(let W of this._def.checks)if(W.kind==="max"){if($===null||W.value<$)$=W.value}return $}}G0.create=($)=>{return new G0({checks:[],typeName:L.ZodBigInt,coerce:$?.coerce??!1,...N($)})};class P0 extends S{_parse($){if(this._def.coerce)$.data=Boolean($.data);if(this._getType($)!==z.boolean){let _=this._getOrReturnCtx($);return w(_,{code:Y.invalid_type,expected:z.boolean,received:_.parsedType}),U}return h($.data)}}P0.create=($)=>{return new P0({typeName:L.ZodBoolean,coerce:$?.coerce||!1,...N($)})};class V0 extends S{_parse($){if(this._def.coerce)$.data=new Date($.data);if(this._getType($)!==z.date){let H=this._getOrReturnCtx($);return w(H,{code:Y.invalid_type,expected:z.date,received:H.parsedType}),U}if(Number.isNaN($.data.getTime())){let H=this._getOrReturnCtx($);return w(H,{code:Y.invalid_date}),U}let _=new I,J=void 0;for(let H of this._def.checks)if(H.kind==="min"){if($.data.getTime()<H.value)J=this._getOrReturnCtx($,J),w(J,{code:Y.too_small,message:H.message,inclusive:!0,exact:!1,minimum:H.value,type:"date"}),_.dirty()}else if(H.kind==="max"){if($.data.getTime()>H.value)J=this._getOrReturnCtx($,J),w(J,{code:Y.too_big,message:H.message,inclusive:!0,exact:!1,maximum:H.value,type:"date"}),_.dirty()}else D.assertNever(H);return{status:_.value,value:new Date($.data.getTime())}}_addCheck($){return new V0({...this._def,checks:[...this._def.checks,$]})}min($,W){return this._addCheck({kind:"min",value:$.getTime(),message:V.toString(W)})}max($,W){return this._addCheck({kind:"max",value:$.getTime(),message:V.toString(W)})}get minDate(){let $=null;for(let W of this._def.checks)if(W.kind==="min"){if($===null||W.value>$)$=W.value}return $!=null?new Date($):null}get maxDate(){let $=null;for(let W of this._def.checks)if(W.kind==="max"){if($===null||W.value<$)$=W.value}return $!=null?new Date($):null}}V0.create=($)=>{return new V0({checks:[],coerce:$?.coerce||!1,typeName:L.ZodDate,...N($)})};class o0 extends S{_parse($){if(this._getType($)!==z.symbol){let _=this._getOrReturnCtx($);return w(_,{code:Y.invalid_type,expected:z.symbol,received:_.parsedType}),U}return h($.data)}}o0.create=($)=>{return new o0({typeName:L.ZodSymbol,...N($)})};class I0 extends S{_parse($){if(this._getType($)!==z.undefined){let _=this._getOrReturnCtx($);return w(_,{code:Y.invalid_type,expected:z.undefined,received:_.parsedType}),U}return h($.data)}}I0.create=($)=>{return new I0({typeName:L.ZodUndefined,...N($)})};class f0 extends S{_parse($){if(this._getType($)!==z.null){let _=this._getOrReturnCtx($);return w(_,{code:Y.invalid_type,expected:z.null,received:_.parsedType}),U}return h($.data)}}f0.create=($)=>{return new f0({typeName:L.ZodNull,...N($)})};class B0 extends S{constructor(){super(...arguments);this._any=!0}_parse($){return h($.data)}}B0.create=($)=>{return new B0({typeName:L.ZodAny,...N($)})};class Q0 extends S{constructor(){super(...arguments);this._unknown=!0}_parse($){return h($.data)}}Q0.create=($)=>{return new Q0({typeName:L.ZodUnknown,...N($)})};class r extends S{_parse($){let W=this._getOrReturnCtx($);return w(W,{code:Y.invalid_type,expected:z.never,received:W.parsedType}),U}}r.create=($)=>{return new r({typeName:L.ZodNever,...N($)})};class n0 extends S{_parse($){if(this._getType($)!==z.undefined){let _=this._getOrReturnCtx($);return w(_,{code:Y.invalid_type,expected:z.void,received:_.parsedType}),U}return h($.data)}}n0.create=($)=>{return new n0({typeName:L.ZodVoid,...N($)})};class c extends S{_parse($){let{ctx:W,status:_}=this._processInputParams($),J=this._def;if(W.parsedType!==z.array)return w(W,{code:Y.invalid_type,expected:z.array,received:W.parsedType}),U;if(J.exactLength!==null){let q=W.data.length>J.exactLength.value,Q=W.data.length<J.exactLength.value;if(q||Q)w(W,{code:q?Y.too_big:Y.too_small,minimum:Q?J.exactLength.value:void 0,maximum:q?J.exactLength.value:void 0,type:"array",inclusive:!0,exact:!0,message:J.exactLength.message}),_.dirty()}if(J.minLength!==null){if(W.data.length<J.minLength.value)w(W,{code:Y.too_small,minimum:J.minLength.value,type:"array",inclusive:!0,exact:!1,message:J.minLength.message}),_.dirty()}if(J.maxLength!==null){if(W.data.length>J.maxLength.value)w(W,{code:Y.too_big,maximum:J.maxLength.value,type:"array",inclusive:!0,exact:!1,message:J.maxLength.message}),_.dirty()}if(W.common.async)return Promise.all([...W.data].map((q,Q)=>{return J.type._parseAsync(new p(W,q,W.path,Q))})).then((q)=>{return I.mergeArray(_,q)});let H=[...W.data].map((q,Q)=>{return J.type._parseSync(new p(W,q,W.path,Q))});return I.mergeArray(_,H)}get element(){return this._def.type}min($,W){return new c({...this._def,minLength:{value:$,message:V.toString(W)}})}max($,W){return new c({...this._def,maxLength:{value:$,message:V.toString(W)}})}length($,W){return new c({...this._def,exactLength:{value:$,message:V.toString(W)}})}nonempty($){return this.min(1,$)}}c.create=($,W)=>{return new c({type:$,minLength:null,maxLength:null,exactLength:null,typeName:L.ZodArray,...N(W)})};function b0($){if($ instanceof b){let W={};for(let _ in $.shape){let J=$.shape[_];W[_]=d.create(b0(J))}return new b({...$._def,shape:()=>W})}else if($ instanceof c)return new c({...$._def,type:b0($.element)});else if($ instanceof d)return d.create(b0($.unwrap()));else if($ instanceof J0)return J0.create(b0($.unwrap()));else if($ instanceof a)return a.create($.items.map((W)=>b0(W)));else return $}class b extends S{constructor(){super(...arguments);this._cached=null,this.nonstrict=this.passthrough,this.augment=this.extend}_getCached(){if(this._cached!==null)return this._cached;let $=this._def.shape(),W=D.objectKeys($);return this._cached={shape:$,keys:W},this._cached}_parse($){if(this._getType($)!==z.object){let X=this._getOrReturnCtx($);return w(X,{code:Y.invalid_type,expected:z.object,received:X.parsedType}),U}let{status:_,ctx:J}=this._processInputParams($),{shape:H,keys:q}=this._getCached(),Q=[];if(!(this._def.catchall instanceof r&&this._def.unknownKeys==="strip")){for(let X in J.data)if(!q.includes(X))Q.push(X)}let G=[];for(let X of q){let j=H[X],M=J.data[X];G.push({key:{status:"valid",value:X},value:j._parse(new p(J,M,J.path,X)),alwaysSet:X in J.data})}if(this._def.catchall instanceof r){let X=this._def.unknownKeys;if(X==="passthrough")for(let j of Q)G.push({key:{status:"valid",value:j},value:{status:"valid",value:J.data[j]}});else if(X==="strict"){if(Q.length>0)w(J,{code:Y.unrecognized_keys,keys:Q}),_.dirty()}else if(X==="strip");else throw new Error("Internal ZodObject error: invalid unknownKeys value.")}else{let X=this._def.catchall;for(let j of Q){let M=J.data[j];G.push({key:{status:"valid",value:j},value:X._parse(new p(J,M,J.path,j)),alwaysSet:j in J.data})}}if(J.common.async)return Promise.resolve().then(async()=>{let X=[];for(let j of G){let M=await j.key,O=await j.value;X.push({key:M,value:O,alwaysSet:j.alwaysSet})}return X}).then((X)=>{return I.mergeObjectSync(_,X)});else return I.mergeObjectSync(_,G)}get shape(){return this._def.shape()}strict($){return V.errToObj,new b({...this._def,unknownKeys:"strict",...$!==void 0?{errorMap:(W,_)=>{let J=this._def.errorMap?.(W,_).message??_.defaultError;if(W.code==="unrecognized_keys")return{message:V.errToObj($).message??J};return{message:J}}}:{}})}strip(){return new b({...this._def,unknownKeys:"strip"})}passthrough(){return new b({...this._def,unknownKeys:"passthrough"})}extend($){return new b({...this._def,shape:()=>({...this._def.shape(),...$})})}merge($){return new b({unknownKeys:$._def.unknownKeys,catchall:$._def.catchall,shape:()=>({...this._def.shape(),...$._def.shape()}),typeName:L.ZodObject})}setKey($,W){return this.augment({[$]:W})}catchall($){return new b({...this._def,catchall:$})}pick($){let W={};for(let _ of D.objectKeys($))if($[_]&&this.shape[_])W[_]=this.shape[_];return new b({...this._def,shape:()=>W})}omit($){let W={};for(let _ of D.objectKeys(this.shape))if(!$[_])W[_]=this.shape[_];return new b({...this._def,shape:()=>W})}deepPartial(){return b0(this)}partial($){let W={};for(let _ of D.objectKeys(this.shape)){let J=this.shape[_];if($&&!$[_])W[_]=J;else W[_]=J.optional()}return new b({...this._def,shape:()=>W})}required($){let W={};for(let _ of D.objectKeys(this.shape))if($&&!$[_])W[_]=this.shape[_];else{let H=this.shape[_];while(H instanceof d)H=H._def.innerType;W[_]=H}return new b({...this._def,shape:()=>W})}keyof(){return J$(D.objectKeys(this.shape))}}b.create=($,W)=>{return new b({shape:()=>$,unknownKeys:"strip",catchall:r.create(),typeName:L.ZodObject,...N(W)})};b.strictCreate=($,W)=>{return new b({shape:()=>$,unknownKeys:"strict",catchall:r.create(),typeName:L.ZodObject,...N(W)})};b.lazycreate=($,W)=>{return new b({shape:$,unknownKeys:"strip",catchall:r.create(),typeName:L.ZodObject,...N(W)})};class T0 extends S{_parse($){let{ctx:W}=this._processInputParams($),_=this._def.options;function J(H){for(let Q of H)if(Q.result.status==="valid")return Q.result;for(let Q of H)if(Q.result.status==="dirty")return W.common.issues.push(...Q.ctx.common.issues),Q.result;let q=H.map((Q)=>new m(Q.ctx.common.issues));return w(W,{code:Y.invalid_union,unionErrors:q}),U}if(W.common.async)return Promise.all(_.map(async(H)=>{let q={...W,common:{...W.common,issues:[]},parent:null};return{result:await H._parseAsync({data:W.data,path:W.path,parent:q}),ctx:q}})).then(J);else{let H=void 0,q=[];for(let G of _){let X={...W,common:{...W.common,issues:[]},parent:null},j=G._parseSync({data:W.data,path:W.path,parent:X});if(j.status==="valid")return j;else if(j.status==="dirty"&&!H)H={result:j,ctx:X};if(X.common.issues.length)q.push(X.common.issues)}if(H)return W.common.issues.push(...H.ctx.common.issues),H.result;let Q=q.map((G)=>new m(G));return w(W,{code:Y.invalid_union,unionErrors:Q}),U}}get options(){return this._def.options}}T0.create=($,W)=>{return new T0({options:$,typeName:L.ZodUnion,...N(W)})};var _0=($)=>{if($ instanceof g0)return _0($.schema);else if($ instanceof i)return _0($.innerType());else if($ instanceof Z0)return[$.value];else if($ instanceof M0)return $.options;else if($ instanceof y0)return D.objectValues($.enum);else if($ instanceof k0)return _0($._def.innerType);else if($ instanceof I0)return[void 0];else if($ instanceof f0)return[null];else if($ instanceof d)return[void 0,..._0($.unwrap())];else if($ instanceof J0)return[null,..._0($.unwrap())];else if($ instanceof j2)return _0($.unwrap());else if($ instanceof x0)return _0($.unwrap());else if($ instanceof m0)return _0($._def.innerType);else return[]};class M2 extends S{_parse($){let{ctx:W}=this._processInputParams($);if(W.parsedType!==z.object)return w(W,{code:Y.invalid_type,expected:z.object,received:W.parsedType}),U;let _=this.discriminator,J=W.data[_],H=this.optionsMap.get(J);if(!H)return w(W,{code:Y.invalid_union_discriminator,options:Array.from(this.optionsMap.keys()),path:[_]}),U;if(W.common.async)return H._parseAsync({data:W.data,path:W.path,parent:W});else return H._parseSync({data:W.data,path:W.path,parent:W})}get discriminator(){return this._def.discriminator}get options(){return this._def.options}get optionsMap(){return this._def.optionsMap}static create($,W,_){let J=new Map;for(let H of W){let q=_0(H.shape[$]);if(!q.length)throw new Error(`A discriminator value for key \`${$}\` could not be extracted from all schema options`);for(let Q of q){if(J.has(Q))throw new Error(`Discriminator property ${String($)} has duplicate value ${String(Q)}`);J.set(Q,H)}}return new M2({typeName:L.ZodDiscriminatedUnion,discriminator:$,options:W,optionsMap:J,...N(_)})}}function C2($,W){let _=n($),J=n(W);if($===W)return{valid:!0,data:$};else if(_===z.object&&J===z.object){let H=D.objectKeys(W),q=D.objectKeys($).filter((G)=>H.indexOf(G)!==-1),Q={...$,...W};for(let G of q){let X=C2($[G],W[G]);if(!X.valid)return{valid:!1};Q[G]=X.data}return{valid:!0,data:Q}}else if(_===z.array&&J===z.array){if($.length!==W.length)return{valid:!1};let H=[];for(let q=0;q<$.length;q++){let Q=$[q],G=W[q],X=C2(Q,G);if(!X.valid)return{valid:!1};H.push(X.data)}return{valid:!0,data:H}}else if(_===z.date&&J===z.date&&+$===+W)return{valid:!0,data:$};else return{valid:!1}}class h0 extends S{_parse($){let{status:W,ctx:_}=this._processInputParams($),J=(H,q)=>{if(X2(H)||X2(q))return U;let Q=C2(H.value,q.value);if(!Q.valid)return w(_,{code:Y.invalid_intersection_types}),U;if(G2(H)||G2(q))W.dirty();return{status:W.value,value:Q.data}};if(_.common.async)return Promise.all([this._def.left._parseAsync({data:_.data,path:_.path,parent:_}),this._def.right._parseAsync({data:_.data,path:_.path,parent:_})]).then(([H,q])=>J(H,q));else return J(this._def.left._parseSync({data:_.data,path:_.path,parent:_}),this._def.right._parseSync({data:_.data,path:_.path,parent:_}))}}h0.create=($,W,_)=>{return new h0({left:$,right:W,typeName:L.ZodIntersection,...N(_)})};class a extends S{_parse($){let{status:W,ctx:_}=this._processInputParams($);if(_.parsedType!==z.array)return w(_,{code:Y.invalid_type,expected:z.array,received:_.parsedType}),U;if(_.data.length<this._def.items.length)return w(_,{code:Y.too_small,minimum:this._def.items.length,inclusive:!0,exact:!1,type:"array"}),U;if(!this._def.rest&&_.data.length>this._def.items.length)w(_,{code:Y.too_big,maximum:this._def.items.length,inclusive:!0,exact:!1,type:"array"}),W.dirty();let H=[..._.data].map((q,Q)=>{let G=this._def.items[Q]||this._def.rest;if(!G)return null;return G._parse(new p(_,q,_.path,Q))}).filter((q)=>!!q);if(_.common.async)return Promise.all(H).then((q)=>{return I.mergeArray(W,q)});else return I.mergeArray(W,H)}get items(){return this._def.items}rest($){return new a({...this._def,rest:$})}}a.create=($,W)=>{if(!Array.isArray($))throw new Error("You must pass an array of schemas to z.tuple([ ... ])");return new a({items:$,typeName:L.ZodTuple,rest:null,...N(W)})};class r0 extends S{get keySchema(){return this._def.keyType}get valueSchema(){return this._def.valueType}_parse($){let{status:W,ctx:_}=this._processInputParams($);if(_.parsedType!==z.object)return w(_,{code:Y.invalid_type,expected:z.object,received:_.parsedType}),U;let J=[],H=this._def.keyType,q=this._def.valueType;for(let Q in _.data)J.push({key:H._parse(new p(_,Q,_.path,Q)),value:q._parse(new p(_,_.data[Q],_.path,Q)),alwaysSet:Q in _.data});if(_.common.async)return I.mergeObjectAsync(W,J);else return I.mergeObjectSync(W,J)}get element(){return this._def.valueType}static create($,W,_){if(W instanceof S)return new r0({keyType:$,valueType:W,typeName:L.ZodRecord,...N(_)});return new r0({keyType:u.create(),valueType:$,typeName:L.ZodRecord,...N(W)})}}class a0 extends S{get keySchema(){return this._def.keyType}get valueSchema(){return this._def.valueType}_parse($){let{status:W,ctx:_}=this._processInputParams($);if(_.parsedType!==z.map)return w(_,{code:Y.invalid_type,expected:z.map,received:_.parsedType}),U;let J=this._def.keyType,H=this._def.valueType,q=[..._.data.entries()].map(([Q,G],X)=>{return{key:J._parse(new p(_,Q,_.path,[X,"key"])),value:H._parse(new p(_,G,_.path,[X,"value"]))}});if(_.common.async){let Q=new Map;return Promise.resolve().then(async()=>{for(let G of q){let X=await G.key,j=await G.value;if(X.status==="aborted"||j.status==="aborted")return U;if(X.status==="dirty"||j.status==="dirty")W.dirty();Q.set(X.value,j.value)}return{status:W.value,value:Q}})}else{let Q=new Map;for(let G of q){let{key:X,value:j}=G;if(X.status==="aborted"||j.status==="aborted")return U;if(X.status==="dirty"||j.status==="dirty")W.dirty();Q.set(X.value,j.value)}return{status:W.value,value:Q}}}}a0.create=($,W,_)=>{return new a0({valueType:W,keyType:$,typeName:L.ZodMap,...N(_)})};class E0 extends S{_parse($){let{status:W,ctx:_}=this._processInputParams($);if(_.parsedType!==z.set)return w(_,{code:Y.invalid_type,expected:z.set,received:_.parsedType}),U;let J=this._def;if(J.minSize!==null){if(_.data.size<J.minSize.value)w(_,{code:Y.too_small,minimum:J.minSize.value,type:"set",inclusive:!0,exact:!1,message:J.minSize.message}),W.dirty()}if(J.maxSize!==null){if(_.data.size>J.maxSize.value)w(_,{code:Y.too_big,maximum:J.maxSize.value,type:"set",inclusive:!0,exact:!1,message:J.maxSize.message}),W.dirty()}let H=this._def.valueType;function q(G){let X=new Set;for(let j of G){if(j.status==="aborted")return U;if(j.status==="dirty")W.dirty();X.add(j.value)}return{status:W.value,value:X}}let Q=[..._.data.values()].map((G,X)=>H._parse(new p(_,G,_.path,X)));if(_.common.async)return Promise.all(Q).then((G)=>q(G));else return q(Q)}min($,W){return new E0({...this._def,minSize:{value:$,message:V.toString(W)}})}max($,W){return new E0({...this._def,maxSize:{value:$,message:V.toString(W)}})}size($,W){return this.min($,W).max($,W)}nonempty($){return this.min(1,$)}}E0.create=($,W)=>{return new E0({valueType:$,minSize:null,maxSize:null,typeName:L.ZodSet,...N(W)})};class C0 extends S{constructor(){super(...arguments);this.validate=this.implement}_parse($){let{ctx:W}=this._processInputParams($);if(W.parsedType!==z.function)return w(W,{code:Y.invalid_type,expected:z.function,received:W.parsedType}),U;function _(Q,G){return i0({data:Q,path:W.path,errorMaps:[W.common.contextualErrorMap,W.schemaErrorMap,K0(),W0].filter((X)=>!!X),issueData:{code:Y.invalid_arguments,argumentsError:G}})}function J(Q,G){return i0({data:Q,path:W.path,errorMaps:[W.common.contextualErrorMap,W.schemaErrorMap,K0(),W0].filter((X)=>!!X),issueData:{code:Y.invalid_return_type,returnTypeError:G}})}let H={errorMap:W.common.contextualErrorMap},q=W.data;if(this._def.returns instanceof U0){let Q=this;return h(async function(...G){let X=new m([]),j=await Q._def.args.parseAsync(G,H).catch((K)=>{throw X.addIssue(_(G,K)),X}),M=await Reflect.apply(q,this,j);return await Q._def.returns._def.type.parseAsync(M,H).catch((K)=>{throw X.addIssue(J(M,K)),X})})}else{let Q=this;return h(function(...G){let X=Q._def.args.safeParse(G,H);if(!X.success)throw new m([_(G,X.error)]);let j=Reflect.apply(q,this,X.data),M=Q._def.returns.safeParse(j,H);if(!M.success)throw new m([J(j,M.error)]);return M.data})}}parameters(){return this._def.args}returnType(){return this._def.returns}args(...$){return new C0({...this._def,args:a.create($).rest(Q0.create())})}returns($){return new C0({...this._def,returns:$})}implement($){return this.parse($)}strictImplement($){return this.parse($)}static create($,W,_){return new C0({args:$?$:a.create([]).rest(Q0.create()),returns:W||Q0.create(),typeName:L.ZodFunction,...N(_)})}}class g0 extends S{get schema(){return this._def.getter()}_parse($){let{ctx:W}=this._processInputParams($);return this._def.getter()._parse({data:W.data,path:W.path,parent:W})}}g0.create=($,W)=>{return new g0({getter:$,typeName:L.ZodLazy,...N(W)})};class Z0 extends S{_parse($){if($.data!==this._def.value){let W=this._getOrReturnCtx($);return w(W,{received:W.data,code:Y.invalid_literal,expected:this._def.value}),U}return{status:"valid",value:$.data}}get value(){return this._def.value}}Z0.create=($,W)=>{return new Z0({value:$,typeName:L.ZodLiteral,...N(W)})};function J$($,W){return new M0({values:$,typeName:L.ZodEnum,...N(W)})}class M0 extends S{_parse($){if(typeof $.data!=="string"){let W=this._getOrReturnCtx($),_=this._def.values;return w(W,{expected:D.joinValues(_),received:W.parsedType,code:Y.invalid_type}),U}if(!this._cache)this._cache=new Set(this._def.values);if(!this._cache.has($.data)){let W=this._getOrReturnCtx($),_=this._def.values;return w(W,{received:W.data,code:Y.invalid_enum_value,options:_}),U}return h($.data)}get options(){return this._def.values}get enum(){let $={};for(let W of this._def.values)$[W]=W;return $}get Values(){let $={};for(let W of this._def.values)$[W]=W;return $}get Enum(){let $={};for(let W of this._def.values)$[W]=W;return $}extract($,W=this._def){return M0.create($,{...this._def,...W})}exclude($,W=this._def){return M0.create(this.options.filter((_)=>!$.includes(_)),{...this._def,...W})}}M0.create=J$;class y0 extends S{_parse($){let W=D.getValidEnumValues(this._def.values),_=this._getOrReturnCtx($);if(_.parsedType!==z.string&&_.parsedType!==z.number){let J=D.objectValues(W);return w(_,{expected:D.joinValues(J),received:_.parsedType,code:Y.invalid_type}),U}if(!this._cache)this._cache=new Set(D.getValidEnumValues(this._def.values));if(!this._cache.has($.data)){let J=D.objectValues(W);return w(_,{received:_.data,code:Y.invalid_enum_value,options:J}),U}return h($.data)}get enum(){return this._def.values}}y0.create=($,W)=>{return new y0({values:$,typeName:L.ZodNativeEnum,...N(W)})};class U0 extends S{unwrap(){return this._def.type}_parse($){let{ctx:W}=this._processInputParams($);if(W.parsedType!==z.promise&&W.common.async===!1)return w(W,{code:Y.invalid_type,expected:z.promise,received:W.parsedType}),U;let _=W.parsedType===z.promise?W.data:Promise.resolve(W.data);return h(_.then((J)=>{return this._def.type.parseAsync(J,{path:W.path,errorMap:W.common.contextualErrorMap})}))}}U0.create=($,W)=>{return new U0({type:$,typeName:L.ZodPromise,...N(W)})};class i extends S{innerType(){return this._def.schema}sourceType(){return this._def.schema._def.typeName===L.ZodEffects?this._def.schema.sourceType():this._def.schema}_parse($){let{status:W,ctx:_}=this._processInputParams($),J=this._def.effect||null,H={addIssue:(q)=>{if(w(_,q),q.fatal)W.abort();else W.dirty()},get path(){return _.path}};if(H.addIssue=H.addIssue.bind(H),J.type==="preprocess"){let q=J.transform(_.data,H);if(_.common.async)return Promise.resolve(q).then(async(Q)=>{if(W.value==="aborted")return U;let G=await this._def.schema._parseAsync({data:Q,path:_.path,parent:_});if(G.status==="aborted")return U;if(G.status==="dirty")return R0(G.value);if(W.value==="dirty")return R0(G.value);return G});else{if(W.value==="aborted")return U;let Q=this._def.schema._parseSync({data:q,path:_.path,parent:_});if(Q.status==="aborted")return U;if(Q.status==="dirty")return R0(Q.value);if(W.value==="dirty")return R0(Q.value);return Q}}if(J.type==="refinement"){let q=(Q)=>{let G=J.refinement(Q,H);if(_.common.async)return Promise.resolve(G);if(G instanceof Promise)throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");return Q};if(_.common.async===!1){let Q=this._def.schema._parseSync({data:_.data,path:_.path,parent:_});if(Q.status==="aborted")return U;if(Q.status==="dirty")W.dirty();return q(Q.value),{status:W.value,value:Q.value}}else return this._def.schema._parseAsync({data:_.data,path:_.path,parent:_}).then((Q)=>{if(Q.status==="aborted")return U;if(Q.status==="dirty")W.dirty();return q(Q.value).then(()=>{return{status:W.value,value:Q.value}})})}if(J.type==="transform")if(_.common.async===!1){let q=this._def.schema._parseSync({data:_.data,path:_.path,parent:_});if(!q0(q))return U;let Q=J.transform(q.value,H);if(Q instanceof Promise)throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");return{status:W.value,value:Q}}else return this._def.schema._parseAsync({data:_.data,path:_.path,parent:_}).then((q)=>{if(!q0(q))return U;return Promise.resolve(J.transform(q.value,H)).then((Q)=>({status:W.value,value:Q}))});D.assertNever(J)}}i.create=($,W,_)=>{return new i({schema:$,typeName:L.ZodEffects,effect:W,...N(_)})};i.createWithPreprocess=($,W,_)=>{return new i({schema:W,effect:{type:"preprocess",transform:$},typeName:L.ZodEffects,...N(_)})};class d extends S{_parse($){if(this._getType($)===z.undefined)return h(void 0);return this._def.innerType._parse($)}unwrap(){return this._def.innerType}}d.create=($,W)=>{return new d({innerType:$,typeName:L.ZodOptional,...N(W)})};class J0 extends S{_parse($){if(this._getType($)===z.null)return h(null);return this._def.innerType._parse($)}unwrap(){return this._def.innerType}}J0.create=($,W)=>{return new J0({innerType:$,typeName:L.ZodNullable,...N(W)})};class k0 extends S{_parse($){let{ctx:W}=this._processInputParams($),_=W.data;if(W.parsedType===z.undefined)_=this._def.defaultValue();return this._def.innerType._parse({data:_,path:W.path,parent:W})}removeDefault(){return this._def.innerType}}k0.create=($,W)=>{return new k0({innerType:$,typeName:L.ZodDefault,defaultValue:typeof W.default==="function"?W.default:()=>W.default,...N(W)})};class m0 extends S{_parse($){let{ctx:W}=this._processInputParams($),_={...W,common:{...W.common,issues:[]}},J=this._def.innerType._parse({data:_.data,path:_.path,parent:{..._}});if(v0(J))return J.then((H)=>{return{status:"valid",value:H.status==="valid"?H.value:this._def.catchValue({get error(){return new m(_.common.issues)},input:_.data})}});else return{status:"valid",value:J.status==="valid"?J.value:this._def.catchValue({get error(){return new m(_.common.issues)},input:_.data})}}removeCatch(){return this._def.innerType}}m0.create=($,W)=>{return new m0({innerType:$,typeName:L.ZodCatch,catchValue:typeof W.catch==="function"?W.catch:()=>W.catch,...N(W)})};class s0 extends S{_parse($){if(this._getType($)!==z.nan){let _=this._getOrReturnCtx($);return w(_,{code:Y.invalid_type,expected:z.nan,received:_.parsedType}),U}return{status:"valid",value:$.data}}}s0.create=($)=>{return new s0({typeName:L.ZodNaN,...N($)})};var Z8=Symbol("zod_brand");class j2 extends S{_parse($){let{ctx:W}=this._processInputParams($),_=W.data;return this._def.type._parse({data:_,path:W.path,parent:W})}unwrap(){return this._def.type}}class t0 extends S{_parse($){let{status:W,ctx:_}=this._processInputParams($);if(_.common.async)return(async()=>{let H=await this._def.in._parseAsync({data:_.data,path:_.path,parent:_});if(H.status==="aborted")return U;if(H.status==="dirty")return W.dirty(),R0(H.value);else return this._def.out._parseAsync({data:H.value,path:_.path,parent:_})})();else{let J=this._def.in._parseSync({data:_.data,path:_.path,parent:_});if(J.status==="aborted")return U;if(J.status==="dirty")return W.dirty(),{status:"dirty",value:J.value};else return this._def.out._parseSync({data:J.value,path:_.path,parent:_})}}static create($,W){return new t0({in:$,out:W,typeName:L.ZodPipeline})}}class x0 extends S{_parse($){let W=this._def.innerType._parse($),_=(J)=>{if(q0(J))J.value=Object.freeze(J.value);return J};return v0(W)?W.then((J)=>_(J)):_(W)}unwrap(){return this._def.innerType}}x0.create=($,W)=>{return new x0({innerType:$,typeName:L.ZodReadonly,...N(W)})};function e2($,W){let _=typeof $==="function"?$(W):typeof $==="string"?{message:$}:$;return typeof _==="string"?{message:_}:_}function H$($,W={},_){if($)return B0.create().superRefine((J,H)=>{let q=$(J);if(q instanceof Promise)return q.then((Q)=>{if(!Q){let G=e2(W,J),X=G.fatal??_??!0;H.addIssue({code:"custom",...G,fatal:X})}});if(!q){let Q=e2(W,J),G=Q.fatal??_??!0;H.addIssue({code:"custom",...Q,fatal:G})}return});return B0.create()}var y8={object:b.lazycreate},L;(function($){$.ZodString="ZodString",$.ZodNumber="ZodNumber",$.ZodNaN="ZodNaN",$.ZodBigInt="ZodBigInt",$.ZodBoolean="ZodBoolean",$.ZodDate="ZodDate",$.ZodSymbol="ZodSymbol",$.ZodUndefined="ZodUndefined",$.ZodNull="ZodNull",$.ZodAny="ZodAny",$.ZodUnknown="ZodUnknown",$.ZodNever="ZodNever",$.ZodVoid="ZodVoid",$.ZodArray="ZodArray",$.ZodObject="ZodObject",$.ZodUnion="ZodUnion",$.ZodDiscriminatedUnion="ZodDiscriminatedUnion",$.ZodIntersection="ZodIntersection",$.ZodTuple="ZodTuple",$.ZodRecord="ZodRecord",$.ZodMap="ZodMap",$.ZodSet="ZodSet",$.ZodFunction="ZodFunction",$.ZodLazy="ZodLazy",$.ZodLiteral="ZodLiteral",$.ZodEnum="ZodEnum",$.ZodEffects="ZodEffects",$.ZodNativeEnum="ZodNativeEnum",$.ZodOptional="ZodOptional",$.ZodNullable="ZodNullable",$.ZodDefault="ZodDefault",$.ZodCatch="ZodCatch",$.ZodPromise="ZodPromise",$.ZodBranded="ZodBranded",$.ZodPipeline="ZodPipeline",$.ZodReadonly="ZodReadonly"})(L||(L={}));var k8=($,W={message:`Input not instance of ${$.name}`})=>H$((_)=>_ instanceof $,W),q$=u.create,Q$=X0.create,m8=s0.create,x8=G0.create,X$=P0.create,l8=V0.create,u8=o0.create,c8=I0.create,d8=f0.create,p8=B0.create,i8=Q0.create,o8=r.create,n8=n0.create,r8=c.create,a8=b.create,s8=b.strictCreate,t8=T0.create,e8=M2.create,$4=h0.create,W4=a.create,_4=r0.create,J4=a0.create,H4=E0.create,q4=C0.create,Q4=g0.create,X4=Z0.create,G4=M0.create,M4=y0.create,j4=U0.create,Y4=i.create,z4=d.create,w4=J0.create,R4=i.createWithPreprocess,V4=t0.create,B4=()=>q$().optional(),E4=()=>Q$().optional(),U4=()=>X$().optional(),L4={string:($)=>u.create({...$,coerce:!0}),number:($)=>X0.create({...$,coerce:!0}),boolean:($)=>P0.create({...$,coerce:!0}),bigint:($)=>G0.create({...$,coerce:!0}),date:($)=>V0.create({...$,coerce:!0})};var O4=U;function P2($,W){if(!$)return-1;let _=W(0),J=W($-1);if(_<0)return-1;if(_===0)return 0;if(J>0)return~$;if(J===0)return $-1;let H=0,q=$-1;while(q-H>1){let Q=H+q>>1,G=W(Q);if(G>0)H=Q;else if(G<0)q=Q;else return Q}return~q}function I2($,W,_){let J=W(_),H=P2($.length,(q)=>J<W($[q])?-1:1);$.splice(~H,0,_)}class G${_chunks=[];_length=0;get length(){return this._length}_find($){return P2(this._chunks.length,(W)=>{let[_,J]=this._chunks[W];if($<_)return-1;if($>=_+J.length)return 1;return 0})}apply($){if($.length<this._length)throw new Error("Target too small.");for(let[W,_]of this._chunks)for(let J=0;J<_.length;J++)$[W+J]=_[J]}chunks(){return this._chunks}get($){let W=this._find($);if(W<0)return;let[_,J]=this._chunks[W];return J[$-_]}set($,...W){this.setInternal($,W)}setInternal($,W){if(!W.length)return;let _=$+W.length;this._length=Math.max(this._length,_);let J=this._find($),H=this._find(_);if(J>=0&&J===H){let[X,j]=this._chunks[J];for(let M=0;M<W.length;M++)j[$+M-X]=W[M];return}let q=this._chunks[~J-1];if(q&&q[0]+q[1].length===$)J=~J-1;if(this._chunks[~H]?.[0]===_)H=~H;if(J>=0){let[X,j]=this._chunks[J];if(H!==J||!Array.isArray(W))W=F4(j,$-X,W);else W.unshift(...j.slice(0,$-X));$=X}if(H>=0){let[X,j]=this._chunks[H];W=S4(W,_-X,j)}let Q=J<0?~J:J,G=H<0?~H:H;if(H>=0)G++;if(!Array.isArray(W))W=Array.from(W);this._chunks.splice(Q,G-Q,[$,W])}splice($,W=1){let _=$+W,J=this._find($),H=this._find(_),q=J>=0?this._chunks[J]:void 0,Q=H>=0?this._chunks[H]:void 0;if(q){let M=$-q[0];if(M)q=[q[0],q===Q?q[1].slice(0,M):M$(q[1],M)];else q=void 0,J=~J}if(Q){if(Q=[_,j$(Q[1],_-Q[0])],!Q[1].length)Q=void 0,H=~H}let G=[];if(q)G.push(q);if(Q)G.push(Q);let X=J<0?~J:J,j=H<0?~H:H;if(H>=0)j++;this._chunks.splice(X,j-X,...G)}slice($,W){if(W<=$)return[];let _=this._find($);if(_<0)throw new Error(`Absent: ${$}`);let[J,H]=this._chunks[_];if(J+H.length<W)throw new Error(`Absent: ${J+H.length}`);return H.slice($-J,W-J)}}class L0 extends G${set($,...W){this.setInternal($,W[0]instanceof Uint8Array?W[0]:Uint8Array.from(W))}search($,W,_){return this.pattern($).search(W,_)}pattern($){if(!$.length)return{search:(G=0)=>G};let W=$.length,_=new Array(256).fill(W);for(let G=0;G<$.length;G++)_[$[G]]=W-1-G;let J=[],H=W;for(let G=W;G>0;--G){if(q(G))H=G;J[W-G]=H-G+W;for(let X=0;X<W-1;++X){let j=Q(X);J[j]=W-1-X+j}}return{search:(G=0,X=this._length)=>{if(!this._chunks.length||X<G)return-1;let j=this._find(G),M=0;if(j>=0)M=G-this._chunks[j][0];else j=~j;while(j<this._chunks.length){let[O,K]=this._chunks[j++],A=Math.min(X-O,K.length);if(A<0)break;for(let B=W-1+M,k;B<A;){for(k=W-1;$[k]===K[B];--B,--k)if(k===0)return B+O;B+=Math.max(J[W-1-k],_[K[B]])}M=0}return-1}};function q(G){for(let X=G,j=0;X<W;++X,++j)if($[X]!==$[j])return!1;return!0}function Q(G){let X=0;for(let j=G,M=W-1;j>=0&&$[j]===$[M];--j,--M)++X;return X}}addOffset($){let W=new L0;for(let[_,J]of this._chunks)W._chunks.push([_+$,J]);return W}toIpsPatch(){let $=8;for(let[,J]of this._chunks)$+=5+J.length;let W=new Uint8Array($),_=5;W[0]=80,W[1]=65,W[2]=84,W[3]=67,W[4]=72;for(let[J,H]of this._chunks){if(H.length>65535)throw new Error("Oops!");W[_++]=J>>>16,W[_++]=J>>>8&255,W[_++]=J&255,W[_++]=H.length>>>8,W[_++]=H.length&255,W.subarray(_,_+H.length).set(H),_+=H.length}return W[_]=69,W[_+1]=79,W[_+2]=70,W}toIpsHexString(){return N4(this.toIpsPatch())}}function N4($){let W=[...$],_=[];for(let J=0;J<W.length;J+=16)_.push([J.toString(16).padStart(8,"0")+":",...W.slice(J,J+16).map((H)=>H.toString(16).padStart(2,"0"))].join(" "));return _.join(`
`)}function F4($,W,_){let J=$.length;if(_.length<J||!Array.isArray(_))return $.splice(W,J-W,..._),$;return _.unshift(...M$($,W)),_}function S4($,W,_){let J=_.length;if($.length<J||!Array.isArray($))return _.splice(0,W,...$),_;return $.push(...j$(_,W)),$}function M$($,W){let _=$.length;if(W<<1<_)return $.slice(0,W);return $.splice(W,_-W),$}function j$($,W){let _=$.length;if(W<<1<_)return $.splice(0,W),$;return $.slice(W)}class D4{data=new Uint8Array(16);add($){let W=$>>>3;if(W>=this.data.length){let _=this.data.length;while(_<=W)_<<=1;let J=new Uint8Array(_);J.subarray(0,this.data.length).set(this.data),this.data=J}this.data[W]|=1<<($&7)}delete($){let W=$>>>3;if(W<this.data.length)this.data[W]&=~(1<<($&7))}has($){return Boolean((this.data[$>>>3]||0)&1<<($&7))}}class l0{data=[];[Symbol.iterator](){return this.data[Symbol.iterator]()}_find($){return P2(this.data.length,(W)=>{let _=this.data[W];if($<_[0])return-1;if($>=_[1])return 1;return 0})}has($){return this._find($)>=0}add($,W){let _=this._find($),J=this._find(W);if(this.data[~_-1]?.[1]===$)_=~_-1;if(this.data[~J]?.[0]===W)J=~J;let H=[$,W];if(_>=0)H[0]=this.data[_][0];if(J>=0)H[1]=this.data[J][1];let q=_<0?~_:_,Q=J<0?~J:J;if(J>=0)Q++;this.data.splice(q,Q-q,H)}delete($,W){let _=this._find($),J=this._find(W),H=_>=0?this.data[_]:void 0,q=J>=0?this.data[J]:void 0;if(H){if(H=[H[0],Math.min(H[1],$)],H[0]===H[1])H=void 0,_=~_}if(q){if(q=[Math.max(q[0],W),q[1]],q[0]===q[1])q=void 0,J=~J}let Q=[];if(H)Q.push(H);if(q)Q.push(q);let G=_<0?~_:_,X=J<0?~J:J;if(J>=0)X++;this.data.splice(G,X-G,...Q)}tail($){let W=this._find($);if(W<0)W=~W;let _=this.data;return{[Symbol.iterator](){return this},next(){if(W>=_.length)return{value:void 0,done:!0};let J=_[W++];return{value:[Math.max($,J[0]),J[1]],done:!1}}}}}function Y2($){throw new Error(`non-exhaustive check: ${$}`)}var A4=R.object({file:R.string(),line:R.number(),column:R.number()}),f2=A4.extend({parent:R.lazy(()=>f2).optional()}),Y$={token:"lb"},z$={token:"lc"},O0={token:"lp"};var w$={token:"rc"},K4={token:"rp"},T2={token:"eol"},h2={token:"eof"},R$={token:"cs",str:".define"},z2={token:"cs",str:".eol"},g2={token:"cs",str:".else"},Z2={token:"cs",str:".elseif"},V$={token:"cs",str:".endif"},B$={token:"cs",str:".endmacro"},E$={token:"cs",str:".endrepeat"};var y2={token:"cs",str:".local"},U$={token:"cs",str:".macro"},L$={token:"cs",str:".repeat"},w2={token:"cs",str:".set"};var O$={token:"cs",str:".bytestr"};var s={token:"op",str:":"},H0={token:"op",str:","},N$={token:"op",str:"*"},F$={token:"op",str:"#"},R2={token:"op",str:"="},S$=new Map([[".addr",".word"],[".bank",".bankbyte"],[".byt",".byte"],[".def",".defined"],[".endmac",".endmacro"],[".endrep",".endrepeat"],[".exitmac",".exitmacro"],[".mac",".macro"],[".undef",".undefine"]]);function E($,W){if(!$||!W)return!1;if($.token!==W.token)return!1;if($.token==="grp")return!1;if($.str!==W.str)return!1;if($.num!==W.num)return!1;return!0}function y($){switch($.token){case"num":return`NUM[$${$.num.toString(16)}]`;case"str":return`STR[$${$.str}]`;case"lb":return"[";case"rb":return"]";case"grp":return"{";case"lc":return"{";case"rc":return"}";case"lp":return"(";case"rp":return")";case"eol":return"EOL";case"eof":return"EOF";case"ident":return $.str;case"cs":case"op":return`${($.rawStr??$.str).toUpperCase()}`;default:Y2($)}}function v($){let W=$.source;if(!W)return"";let _=W.parent?v({source:W.parent}):"";return`
  at ${W.file}:${W.line}:${W.column}${_}`}function F($){if(!$)return"at unknown";let W=$;return(W.token?y(W):"")+v($)}function C($,W="end of line"){if($)throw new Error(`Expected ${W}: ${F($)}`)}function D$($,W,_){if(!W){if(!_)throw new Error(`Expected ${y($)}`);throw new Error(`Expected ${y($)} after ${F(W)}`)}if(!E($,W))throw new Error(`Expected ${y($)}: ${F(W)}`)}function f($,W){return v$("ident","identifier",$,W)}function A$($){return b$("ident","identifier",$)}function x($,W){return v$("str","constant string",$,W)}function K$($){return b$("str","constant string",$)}function v$($,W,_,J){if(!_){if(!J)throw new Error(`Expected ${W}`);throw new Error(`Expected ${W} after ${F(J)}`)}if(_.token!==$)throw new Error(`Expected ${W}: ${F(_)}`);return _.str}function b$($,W,_){if(!_)return;if(_.token!==$)throw new Error(`Expected ${W}: ${F(_)}`);return _.str}function e0($){if(!$.length)return[];let W=[];for(let _=0;_<=$.length;_+=2){let J=$[_];if(J?.token!=="ident"){if(J)throw new Error(`Expected identifier: ${F(J)}`);let H=$[$.length-1];throw new Error(`Expected identifier after ${F(H)}`)}else if(_+1<$.length&&!E($[_+1],H0)){let H=$[_+1];throw new Error(`Expected comma: ${F(H)}`)}W.push(J.str)}return W}function t($,W){let _=$[W++].token;if(_!=="lp"&&_!=="lb")throw new Error("non-grouping token");let J=_==="lp"?"rp":"rb",H=1;for(;W<$.length;W++){let q=$[W].token;if(H+=Number(q===_)-Number(q===J),!H)return W}return-1}function g($,W=0,_=$.length){let J=[],H=[J],q=0;for(let Q=W;Q<_;Q++){let G=$[Q];if(!q&&E(G,H0))H.push(J=[]);else{if(J.push(G),E(G,O0))q++;if(E(G,K4)){if(--q<0)throw new Error(`Unbalanced paren${v(G)}`)}}}return H}function C$($,W){let _=new Map,J,H=[];if(W>=$.length)return _;if(!E($[W],s))throw new Error(`Unexpected: ${F($[W])}`);for(let q=W+1;q<$.length;q++){let Q=$[q];if(E(Q,s)){if(J==null)throw new Error(`Missing key${v(Q)}`);_.set(J,H),J=void 0,H=[]}else if(J==null)J=f(Q);else H.push(Q)}if(J!=null)_.set(J,H);else f(void 0,$[$.length-1]);return _}function P$($,W){let _=k2($,H0,W);return _<0?$.length:_}function k2($,W,_){for(let J=_;J<$.length;J++)if(E($[J],W))return J;return-1}function m2($){let W=0;for(let _ of $)if(_.token==="grp")W+=2+m2(_.inner);else W++;return W}function u0($,W){return $.token==="ident"&&$.str.toLowerCase()===W}function c0($){switch($.token){case"cs":case"ident":case"str":case"op":return $.str}throw new Error(`Non-string token: ${F($)}`)}var v4=R.object({rel:R.boolean().optional(),chunk:R.number().optional(),org:R.number().optional(),bank:R.number().optional(),offset:R.number().optional(),size:R.number().optional()}),b4=R.object({op:R.string(),num:R.number().optional(),str:R.string().optional(),meta:v4.optional(),sym:R.string().optional(),source:f2.optional()}),W2=b4.extend({args:R.lazy(()=>W2.array()).optional()});function Y0($,W){function _(H){if(!H.args)return H;return{...H,args:H.args.map((q)=>J(q,H))}}function J(H,q){let Q=H.source;if(H=W(H,_,q),Q&&!H.source)H.source=Q;return H}return J($)}function h$($,W){return Y0($,(_,J)=>W(J(_)))}function Z($){let W=l2.get($.op)??$.op;switch(W){case".move":case"im":case"sym":return $;case"num":if($.meta?.rel&&$.meta.org!=null){let{rel:_,...J}=$.meta;return{op:"num",num:$.num+J.org,meta:J}}return $;case".max":return I$($,Math.max);case".min":return I$($,Math.min);default:}if($.args?.length===1)switch(W){case"+":return $.args[0];case"-":return $2($,(_)=>-_);case"~":return $2($,(_)=>~_);case"!":return $2($,(_)=>+!_);case"<":return $2($,(_)=>_&255);case">":return $2($,(_)=>_>>8&255);case"^":return C4($.args[0].meta?.bank)??$;default:throw new Error(`Unknown unary operator: ${W}`)}switch(W){case"str":return $;case".match":return f$($,(_,J)=>_.num&&J.num||_.str&&J.str||_.sym&&J.sym?1:0);case".xmatch":return f$($,(_,J)=>_.num!==void 0&&J.num!==void 0&&_.num===J.num||_.str!==void 0&&J.str!==void 0&&_.str===J.str||_.sym!==void 0&&J.sym!==void 0&&_.sym===J.sym?1:0);case"+":return P4($);case"-":return I4($);case"*":return T($,(_,J)=>_*J);case"/":return T($,(_,J)=>Math.floor(_/J));case".mod":return T($,(_,J)=>_%J);case"&":return T($,(_,J)=>_&J);case"|":return T($,(_,J)=>_|J);case"^":return T($,(_,J)=>_^J);case"<<":return T($,(_,J)=>_<<J);case">>":return T($,(_,J)=>_>>>J);case"<":return T($,(_,J)=>+(_<J));case"<=":return T($,(_,J)=>+(_<=J));case">":return T($,(_,J)=>+(_>J));case">=":return T($,(_,J)=>+(_>=J));case"=":return T($,(_,J)=>+(_==J));case"<>":return T($,(_,J)=>+(_!=J));case"&&":return T($,(_,J)=>_&&J);case"||":return T($,(_,J)=>_||J);case".xor":return T($,(_,J)=>!_&&J||!J&&_||0);default:throw new Error(`Unknown operator: ${W} Expr: ${JSON.stringify($)}`)}}function u2($,W=[]){for(let _ of $.args||[])u2(_,W);if($.op==="sym"&&$.sym)W.push($.sym);return W}function g$($){if($.op==="sym"&&$.sym)return $.sym;throw new Error(`Expected identifier but got op: ${$.op}`)}function e($,W=0,_){let[J,H]=V2($,W,_);if(H<$.length)throw V2($,W,_),new Error(`Garbage after expression: ${F($[H])}`);else if(!J)throw new Error("No expression?");return J}function V2($,W=0,_){let J=[],H=[];function q(){let[X,[,,j]]=J.pop(),M=H.splice(H.length-j,j);if(M.length!==j)throw new Error(`shunting parse failed? ${F($[G])}`);H.push(T$({op:X,args:M}))}let Q=!0,G=W;for(;G<$.length;G++){let X=$[G];if(Q)if(X.token==="cs"||X.token==="op"){let j=l2.get(X.str),M=h4.get(j??X.str);if(M)J.push([X.str,M]);else if(X.token==="cs"){let O=X.str;if(!g4.has(O))throw new Error(`No such function: ${F(X)}`);let K=$[G+1];if(K?.token!=="lp")throw new Error(`Bad funcall: ${F(K??X)}`);let A=t($,G+1);if(A<0)throw new Error(`Never closed: ${F(K)}`);let B=[];for(let k of g($,G+2,A))B.push(e(k,0,_));G=A,H.push(T$({op:O,args:B})),Q=!1}else if(E(X,N$))H.push({op:"sym",sym:"*"}),Q=!1;else throw new Error(`Unknown prefix operator: ${F(X)}`)}else if(X.token==="lp"){let j=t($,G);if(j<0)throw new Error(`No close paren: ${F(X)}`);let M=e($.slice(G+1,j),0,_);H.push(M),G=j,Q=!1}else if(X.token==="ident"){let j=_?.get(X.str)?.expr;H.push(j?j:{op:"sym",sym:X.str}),Q=!1}else if(X.token==="num"){let j=X.num;H.push({op:"num",num:j,meta:o(j,X)}),Q=!1}else if(X.token==="str"){let j=X.str;H.push({op:"str",str:j,meta:{size:j.length}}),Q=!1}else throw new Error(`Bad expression token: ${F(X)}`);else{if(E(X,H0))break;if(X.token==="cs"||X.token==="op"){let j=l2.get(X.str),M=T4.get(j??X.str);if(!M)break;while(J.length){let O=J[J.length-1],K=f4(O[1],M);if(K<0)break;if(K===0)throw new Error(`Mixing ${O[0]} and ${X.str} needs explicit parens.${v(X)}`);q()}J.push([X.str,M]),Q=!0}else break}}while(J.length)q();if(!$[W])throw new Error(`No token at ${W}:
${$.map((X)=>"  "+F(X)+`
`)}`);if(H.length!==1)throw new Error(`expression parse failed: nonunique result ${F($[W])}`);if($[W].source)H[0].source=$[W].source;return[H[0],G]}function I$($,W){throw new Error}function C4($){if($==null)return;return{op:"num",num:$,meta:o($)}}function $2($,W){let _=$.args[0];if(!x2(_))return $;let J=W(_.num);return{op:"num",num:J,meta:o(J)}}function T($,W){let[_,J]=$.args;if(!x2(_)||!x2(J))return $;let H=W(_.num,J.num);return{op:"num",num:H,meta:o(H)}}function f$($,W){let[_,J]=$.args,H=W(_,J);return{op:"num",num:H,meta:o(H)}}function P4($){let[W,_]=$.args;if(W.op!=="num"||_.op!=="num")return $;let J={op:"num",num:W.num+_.num};if(W.meta||_.meta){if(W.meta?.rel&&_.meta?.rel)return $;if(W.meta?.rel)J.meta=W.meta;else if(_.meta?.rel)J.meta=_.meta}if(!J.meta?.rel&&J.meta?.size==null)(J.meta||(J.meta={})).size=o(J.num).size;return J}function I4($){let[W,_]=$.args;if(W.op!=="num"||_.op!=="num")return $;let J={op:"num",num:W.num-_.num};if(_.meta?.rel)return W.meta?.rel&&W.meta.chunk===_.meta.chunk?J:$;if(W.meta?.rel)J.meta=W.meta;if(!J.meta?.rel&&J.meta?.size==null)(J.meta||(J.meta={})).size=o(J.num).size;return J}function x2($){return $.op==="num"&&!$.meta?.rel}function f4($,W){if($[0]>W[0])return 1;if($[0]<W[0])return-1;if($[1]!==W[1])return 0;return $[1]}var P=2,N0=1,T4=new Map([["*",[5,4,P]],["/",[5,4,P]],[".mod",[5,3,P]],["&",[5,2,P]],["^",[5,1,P]],["<<",[5,0,P]],[">>",[5,0,P]],["+",[4,2,P]],["-",[4,2,P]],["|",[4,1,P]],["<",[3,0,P]],["<=",[3,0,P]],[">",[3,0,P]],[">=",[3,0,P]],["=",[3,0,P]],["<>",[3,0,P]],["&&",[2,3,P]],[".xor",[2,2,P]],["||",[2,1,P]]]),h4=new Map([["+",[9,-1,N0]],["-",[9,-1,N0]],["~",[9,-1,N0]],["<",[9,-1,N0]],[">",[9,-1,N0]],["^",[9,-1,N0]],["!",[2,-1,N0]]]),g4=new Set([".byteat",".wordat",".match",".xmatch",".max",".min"]),l2=new Map([[".bitand","&"],[".bitxor","^"],[".bitor","|"],[".shl","<<"],[".shr",">>"],[".and","&&"],[".or","||"],[".bitnot","~"],[".lobyte","<"],[".hibyte",">"],[".bankbyte","^"],[".not","!"]]),Z4=new Map([["^",(...$)=>$.length===1?1:Math.max(...$)],["<",()=>1],[">",()=>1],["!",()=>1],["<=",()=>1],[">=",()=>1],["<>",()=>1],["=",()=>1],["&",Math.max],["&&",Math.max],["|",Math.max],["||",Math.max],[".xor",Math.max],[".max",Math.max],[".min",Math.max]]);function T$($){let _=Z4.get($.op)?.(...$.args.map((J)=>Number(J.meta?.size)));if(_)($.meta||($.meta={})).size=_;return $}function o($,W){if($<256&&W&&W.token==="num"&&W.width!=null)return{size:W.width};return{size:0<=$&&$<256?1:2}}var y4=R.object({offset:R.number(),size:R.number(),expr:W2}),k4=R.enum(["forbid","allow","require"]),Z$=R.object({name:R.string().optional(),segments:R.array(R.string()),org:R.number().optional(),subs:R.optional(R.array(y4)),asserts:R.optional(R.array(W2)),overwrite:R.optional(k4)}),s6=Z$.extend({data:R.array(R.number())}),m4=Z$.extend({data:R.string().transform(($)=>new l().decode($))}),x4=R.object({export:R.string().optional(),expr:W2.optional()}),l4=R.object({name:R.string(),bank:R.number().optional(),size:R.number().optional(),offset:R.number().optional(),memory:R.number().optional(),addressing:R.number().optional(),fill:R.number().optional(),out:R.boolean().optional(),overlay:R.string().optional(),default:R.boolean().optional(),free:R.array(R.array(R.number())).optional()}),d0;((t6)=>{function $(_,J){let H={..._,...J},q=[..._.free||[],...J.free||[]];if(q.length)H.free=q;return H}t6.merge=$;function W(_,J){if(_.memory==null||_.size==null)return!1;return J>=_.memory&&J<_.memory+_.size}t6.includesOrg=W})(d0||={});var e6=R.object({name:R.string().optional(),chunks:R.optional(R.array(m4)),symbols:R.optional(R.array(x4)),segments:R.optional(R.array(l4))});class y${line;column;prefix;remainder;match;constructor($,W,_,J,H){this.line=$;this.column=W;this.prefix=_;this.remainder=J;this.match=H}}class c2{content;line;column;prefix="";remainder;lastMatch;constructor($,W=1,_=0){this.content=$;this.line=W;this.column=_;this.remainder=$}advance($){let W=this.remainder.substring(0,$.length);if($!==W)throw new Error(`Non-rooted token: '${$}' vs '${W}'`);this.prefix+=$,this.remainder=this.remainder.substring($.length),$=$.replace(`
`,$.includes("\r")?"":"\r");let _=$.split(/\r/g);if(_.length>1)this.line+=_.length-1,this.column=0;this.column+=_[_.length-1].length}saveState(){return new y$(this.line,this.column,this.prefix,this.remainder,this.lastMatch)}restoreState($){this.line=$.line,this.column=$.column,this.prefix=$.prefix,this.remainder=$.remainder,this.lastMatch=$.match}skip($){let W=$.exec(this.remainder);if(!W)return!1;return this.advance(W[0]),!0}space(){return this.skip(/^[ \t]+/)}newline(){return this.skip(/^(\r\n|\n|\r)/)}lookingAt($){if(typeof $==="string")return this.remainder.startsWith($);return $.test(this.remainder)}token($){let W;if(typeof $==="string"){if(!this.remainder.startsWith($))return!1;W=[$]}else W=$.exec(this.remainder);if(!W)return!1;return W.line=this.line,W.column=this.column,this.lastMatch=W,this.advance(W[0]),!0}lookBehind($){if(typeof $==="string")return this.prefix.endsWith($);let W=$.exec(this.prefix);if(!W)return!1;return W.line=this.line,W.column=this.line,this.lastMatch=W,!0}match(){return this.lastMatch}group($=0){return this.lastMatch?.[$]}eof(){return!this.remainder}}class $0{file;opts;buffer;constructor($,W="input.s",_={}){this.file=W;this.opts=_;this.buffer=new c2($)}async next(){return await new Promise(($)=>{let W=this.token();while(E(W,T2))W=this.token();let _=[[]],J=0;while(!E(W,T2)&&!E(W,h2)){if(E(W,z$))_[J++].push(W),_.push([]);else if(E(W,w$)){if(!J)throw new Error(`Missing open curly: ${F(W)}`);let H=_.pop(),q=_[--J].pop().source,Q={token:"grp",inner:H};if(q)Q.source=q;_[J].push(Q)}else _[J].push(W);W=this.token()}if(J){let H=_[J-1].pop();throw new Error(`Missing close curly: ${F(H)}`)}$(_[0].length?_[0]:void 0)})}token(){while(this.buffer.space()||this.buffer.token(/^;.*/)||this.opts.lineContinuations&&this.buffer.token(/^\\(\r\n|\n|\r)/));if(this.buffer.eof())return h2;let $={file:this.file,line:this.buffer.line,column:this.buffer.column};try{let W=this.tokenInternal();if(!this.opts.skipSourceAnnotations)W.source=$;return W}catch(W){let{file:_,line:J,column:H}=$,q=this.buffer.group();throw q=q?` near '${q}'`:"",W.message+=`
  at ${_}:${J}:${H}${q}`,W}}tokenInternal(){if(this.buffer.newline())return{token:"eol"};if(this.buffer.token(/^@+[a-z0-9_]*/i)||this.buffer.token(/^((::)?[a-z_][a-z0-9_]*)+/i))return this.strTok("ident");if(this.buffer.token(/^\.[a-z][a-z0-9]*/i))return this.csTok();if(this.buffer.token(/^:([+-]\d+|[-+]+|<+rts|>*rts)/))return this.strTok("ident");if(this.buffer.token(/^(:|\++|-+|&&?|\|\|?|[#*/,=~!^]|<[<>=]?|>[>=]?)/))return this.strTok("op");if(this.buffer.token("["))return{token:"lb"};if(this.buffer.token("{"))return{token:"lc"};if(this.buffer.token("("))return{token:"lp"};if(this.buffer.token("]"))return{token:"rb"};if(this.buffer.token("}"))return{token:"rc"};if(this.buffer.token(")"))return{token:"rp"};if(this.buffer.token(/^["']/))return this.tokenizeStr();if(this.buffer.token(/^[$%]?[0-9a-z_]+/i))return this.tokenizeNum();throw new Error("Syntax error")}tokenizeStr(){let $=this.buffer,_=$.match()[0],J="";while(!$.lookingAt(_)){if($.eof())throw new Error(`EOF while looking for ${_}`);if($.token(/^\\u([0-9a-f]{4})/i))J+=String.fromCodePoint(parseInt($.group(1),16));else if($.token(/^\\x([0-9a-f]{2})/i))J+=String.fromCharCode(parseInt($.group(1),16));else if($.token(/^\\(.)/))J+=$.group(1);else $.token(/^./),J+=$.group(0)}return $.token(_),{token:"str",str:J}}strTok($){return{token:$,str:this.buffer.group()}}csTok(){let $=this.buffer.group();return{token:"cs",str:S$.get($.toLowerCase())??$.toLowerCase(),rawStr:$}}tokenizeNum($=this.buffer.group()){if(this.opts.numberSeparators)$=$.replace(/_/g,"");if($[0]==="$")return c4($.substring(1));if($[0]==="%")return i4($.substring(1));if($[0]==="0")return p4($);return d4($)}}function c4($){if(!/^[0-9a-f]+$/i.test($))throw new Error(`Bad hex number: $${$}`);return{token:"num",num:Number.parseInt($,16),width:Math.ceil($.length/2)}}function d4($){if(!/^[0-9]+$/.test($))throw new Error(`Bad decimal number: ${$}`);return{token:"num",num:Number.parseInt($,10)}}function p4($){if(!/^[0-7]+$/.test($))throw new Error(`Bad octal number: ${$}`);return{token:"num",num:Number.parseInt($,8)}}function i4($){if(!/^[01]+$/.test($))throw new Error(`Bad binary number: %${$}`);return{token:"num",num:Number.parseInt($,2),width:Math.ceil($.length/8)}}class p2{symbols=new Map;pickScope($){return[$,this]}resolve($,W={}){let{allowForwardRef:_=!1,ref:J}=W,[H,q]=this.pickScope($),Q=q.symbols.get(H);if(Q){if(H!==$)Q.scoped=!0;return Q}if(!_)return;let G={ref:J};if(q.symbols.set(H,G),H!==$)G.scoped=!0;return G}}class d2 extends p2{parent;kind;global;children=new Map;anonymousChildren=[];constructor($,W){super();this.parent=$;this.kind=W;this.global=$?$.global:this}pickScope($){let W=this,_=$.split(/::/g),J=_.pop();for(let H=0;H<_.length;H++){if(!H&&!_[H]){W=W.global;continue}let q=W.children.get(_[H]);while(!H&&W.parent&&!q)q=(W=W.parent).children.get(_[H]);if(!q){let Q=_.slice(0,H+1).join("::");throw new Error(`Could not resolve scope ${Q}`)}W=q}return[J,W]}}class k$ extends p2{clear(){for(let[$,W]of this.symbols)if(!W.expr){let _=W.ref?v(W.ref):"";throw new Error(`Cheap local label never defined: ${$}${_}`)}this.symbols.clear()}}class _2{cpu;opts;segments=[];segmentData=new Map;segmentStack=[];symbols=[];globals=new Map;currentScope=new d2;cheapLocals=new k$;anonymousForward=[];anonymousReverse=[];relativeForward=[];relativeReverse=[];rtsRefsForward=[];rtsRefsReverse=[];chunks=[];written=new l0;_chunk=void 0;_name=void 0;_org=void 0;_segmentPrefix="";_source;errorToken;_exprMap=void 0;_segmentOffset=0;constructor($=w0.P02,W={}){this.cpu=$;this.opts=W}get chunk(){return this.ensureChunk(),this._chunk}get exprMap(){return this._exprMap||(this._exprMap=new WeakMap)}get overwriteMode(){return this.opts.overwriteMode||"allow"}ensureChunk(){if(!this._chunk){if(this._chunk={segments:this.segments,data:[]},this._org!=null)this._chunk.org=this._org;if(this._name)this._chunk.name=this._name;this.chunks.push(this._chunk),this._chunk.overwrite=this.overwriteMode}}definedSymbol($){if(this.globals.get($)==="import")return!0;let W=this.currentScope,_=!$.includes("::");do{let J=W.resolve($,{allowForwardRef:!1});if(J)return Boolean(J.expr)}while(_&&(W=W.parent));return!1}constantSymbol($){let W=this.currentScope.resolve($,{allowForwardRef:!1});return Boolean(W&&W.expr&&!(W.id<0))}referencedSymbol($){return this.currentScope.resolve($,{allowForwardRef:!1})!=null}evaluate($){if($=this.resolve($),$.op==="num"&&!$.meta?.rel)return $.num;return}pc(){let $=this.chunk.data.length,W={rel:!0,chunk:this.chunks.length-1};if(this._chunk?.org!=null)W.org=this._chunk.org;return Z({op:"num",num:$,meta:W})}symbol($){return Z(e([{token:"ident",str:$}],0,this.currentScope.symbols))}where(){if(!this._chunk)return"";if(this.chunk.org==null)return"";return`${this.chunk.segments.join(",")}:$${(this.chunk.org+this.chunk.data.length).toString(16)}`}resolve($){let W=Y0($,(_,J)=>{while(_.op==="sym"&&_.sym)_=this.resolveSymbol(_);return Z(J(_))});if(this.opts.refExtractor?.ref&&W!==$){let _=this.exprMap.get($)||$;this.exprMap.set(W,_)}return W}resolveSymbol($){let W=$.sym,_=n4(W);if(_.type==="pc")return this.pc();else if(_.type==="anon"&&_.num>0){let q=_.num-1,Q=this.anonymousForward[q];if(Q!=null)return{op:"sym",num:Q};return this.anonymousForward[q]=Q=this.symbols.length,this.symbols.push({id:Q}),{op:"sym",num:Q}}else if(_.type==="rts"&&_.num>0){let q=_.num-1,Q=this.rtsRefsForward[q];if(Q!=null)return{op:"sym",num:Q};return this.rtsRefsForward[q]=Q=this.symbols.length,this.symbols.push({id:Q}),{op:"sym",num:Q}}else if(_.type==="rel"&&_.num>0){let q=this.relativeForward[_.num-1];if(q!=null)return{op:"sym",num:q};return this.relativeForward[W.length-1]=q=this.symbols.length,this.symbols.push({id:q}),{op:"sym",num:q}}else if(_.type==="anon"&&_.num<0){let q=this.anonymousReverse.length+_.num;if(q<0)this.fail(`Bad anonymous backref: ${W}`);return this.anonymousReverse[q]}else if(_.type==="rts"&&_.num<0){let q=this.rtsRefsReverse.length+_.num;if(q<0)this.fail(`Bad rts backref: ${W}`);return this.rtsRefsReverse[q]}else if(_.type==="rel"&&_.num<0){let q=this.relativeReverse[W.length-1];if(q==null)this.fail(`Bad relative backref: ${W}`);return q}let H=(W.startsWith("@")?this.cheapLocals:this.currentScope).resolve(W,{allowForwardRef:!0,ref:$});if(H.expr)return H.expr;if(H.id==null)H.id=this.symbols.length,this.symbols.push(H);return{op:"sym",num:H.id}}chunkData($){return{org:this.chunks[$].org}}closeScopes(){this.cheapLocals.clear();function $(W){for(let _ of W.children.values())$(_);for(let _ of W.anonymousChildren)$(_);for(let[_,J]of W.symbols){if(J.expr||J.id==null)continue;if(W.parent){if(J.scoped)throw new Error(`Symbol '${_}' undefined: ${JSON.stringify(J)}`);let H=W.parent.symbols.get(_);if(!H)W.parent.symbols.set(_,J);else if(H.id!=null&&H.id>=0)J.expr={op:"sym",num:H.id};else if(H.expr)J.expr=H.expr;else throw new Error(`Impossible: ${_}`)}}}if(this.currentScope.parent)throw new Error("Scope never closed");$(this.currentScope);for(let[W,_]of this.globals){let J=this.currentScope.symbols.get(W);if(_==="export"){if(!J?.expr)throw new Error(`Symbol '${W}' undefined`);if(J.id==null)J.id=this.symbols.length,this.symbols.push(J);J.export=W}else if(_==="import"){if(!J)continue;if(J.expr)throw new Error(`Already defined: ${W}`);J.expr={op:"im",sym:W}}else Y2(_)}for(let[W,_]of this.currentScope.symbols)if(!_.expr)throw new Error(`Symbol '${W}' undefined: ${JSON.stringify(_)}`)}module(){this.closeScopes();let $=[];for(let J of this.chunks)$.push({...J,data:Uint8Array.from(J.data)});let W=[];for(let J of this.symbols){if(J.expr==null)throw new Error("Symbol undefined");let H={expr:J.expr};if(J.export!=null)H.export=J.export;W.push(H)}let _=[...this.segmentData.values()];return{chunks:$,symbols:W,segments:_}}async line($){if(E($[1],R2)||E($[1],w2))return;if(this._source=$[0].source,$.length<3&&E($[$.length-1],s))this.label($[0]);else if($[0].token==="cs")this.directive($);else await this.instruction($)}async tokens($){let W;while(W=await $.next())await this.line(W)}directive($){this.errorToken=$[0];try{switch(c0($[0])){case".org":return this.org(this.parseConst($,1));case".reloc":return this.parseNoArgs($,1),this.reloc();case".assert":return this.assert(...this.parseAssert($));case".segment":return this.segment(...this.parseSegmentList($,1,!1));case".byte":return this.byte(...this.parseDataList($,!0));case".bytestr":return this.byteInternal(this.parseByteStr($));case".res":return this.res(...this.parseResArgs($));case".word":return this.word(...this.parseDataList($));case".free":return this.free(this.parseConst($,1));case".segmentprefix":return this.segmentPrefix(this.parseStr($,1));case".import":return this.import(...this.parseIdentifierList($));case".export":return this.export(...this.parseIdentifierList($));case".scope":return this.scope(this.parseOptionalIdentifier($));case".endscope":return this.parseNoArgs($,1),this.endScope();case".proc":return this.proc(this.parseRequiredIdentifier($));case".endproc":return this.parseNoArgs($,1),this.endProc();case".pushseg":return this.pushSeg(...this.parseSegmentList($,1,!0));case".popseg":return this.parseNoArgs($,1),this.popSeg();case".move":return this.move(...this.parseMoveArgs($));case".out":return this.log("info",$);case".warning":return this.log("warn",$);case".error":return this.log("error",$);case".a8":case".i8":case".p02":return}this.fail(`Unknown directive: ${F($[0])}`)}finally{this.errorToken=void 0}}label($){let W,_,J=this.pc();if(typeof $==="string")W=$;else if(W=c0(_=$),$.source)J.source=$.source;if(W===":"){this.anonymousReverse.push(J);let H=this.anonymousForward.shift();if(H!=null)this.symbols[H].expr=J;return}else if(/^\++$/.test(W)){let H=this.relativeForward[W.length-1];if(delete this.relativeForward[W.length-1],H!=null)this.symbols[H].expr=J;return}else if(/^-+$/.test(W)){this.relativeReverse[W.length-1]=J;return}if(!W.startsWith("@")){if(this.cheapLocals.clear(),!this.chunk.name&&!this.chunk.data.length)this.chunk.name=W;if(this.opts.refExtractor?.label&&this.chunk.org!=null)this.opts.refExtractor.label(W,this.chunk.org+this.chunk.data.length,this.chunk.segments)}this.assignSymbol(W,!1,J,_)}assignSym($){this.assign(c0($[0]),this.parseExpr($,2))}setSym($){this.set(c0($[0]),this.parseExpr($,2))}assign($,W){if($.startsWith("@"))this.fail(`Cheap locals may only be labels: ${$}`);if(typeof W!=="number")W=this.resolve(W);if(this.assignSymbol($,!1,W),this.opts.refExtractor?.assign&&typeof W==="number")this.opts.refExtractor.assign($,W)}set($,W){if($.startsWith("@"))this.fail(`Cheap locals may only be labels: ${$}`);if(typeof W!=="number")W=this.resolve(W);this.assignSymbol($,!0,W)}assignSymbol($,W,_,J){if(typeof _==="number")_={op:"num",num:_,meta:o(_)};let H=$.startsWith("@")?this.cheapLocals:this.currentScope,q=H.resolve($,{allowForwardRef:!W,ref:J});if(q&&W!==q.id<0)this.fail(`Cannot change mutability of ${$}`,J);else if(W&&_.op!="num")this.fail("Mutable set requires constant",J);else if(!q){if(!W)throw new Error("impossible");H.symbols.set($,q={id:-1})}else if(!W&&q.expr){let Q=q.expr.source?`
Originally defined${v(q.expr)}`:"",G=J?F(J):$+(this._source?v({source:this._source}):"");throw new Error(`Redefining symbol ${G}${Q}`)}q.expr=_}async instruction(...$){let W,_;if($.length===1&&Array.isArray($[0])){let q=$[0];W=f(q[0]).toLowerCase(),_=this.parseArg(q,1)}else if(typeof $[1]==="string"){W=$[0];let q=new $0($[1]);_=this.parseArg(await q.next(),0)}else{if([W,_]=$,!_)_=["imp"];W=W.toLowerCase()}if(W==="rts"){let q=this.pc();this.rtsRefsReverse.push(q);let Q=this.rtsRefsForward.shift();if(Q!=null)this.symbols[Q].expr=q}let J=this.cpu.op(W),H=_[0];if(H==="add"||H==="a,x"||H==="a,y"){let q=_[1],Q=q.meta?.size||2;if(H==="add"&&Q===1&&"zpg"in J)return this.opcode(J.zpg,1,q);else if(H==="add"&&"abs"in J)return this.opcode(J.abs,2,q);else if(H==="add"&&"rel"in J)return this.relative(J.rel,1,q);else if(H==="a,x"&&Q===1&&"zpx"in J)return this.opcode(J.zpx,1,q);else if(H==="a,x"&&"abx"in J)return this.opcode(J.abx,2,q);else if(H==="a,y"&&Q===1&&"zpy"in J)return this.opcode(J.zpy,1,q);else if(H==="a,y"&&"aby"in J)return this.opcode(J.aby,2,q);this.fail(`Bad address mode ${H} for ${W}`)}if(H in J){let q=this.cpu.argLen(H);if(H==="rel")return this.relative(J[H],q,_[1]);return this.opcode(J[H],q,_[1])}this.fail(`Bad address mode ${H} for ${W}`)}parseArg($,W){if($.length===W)return["imp"];let _=$[W],J=$[W+1];if($.length===W+1){if(u0(_,"a"))return["acc"]}else if(E(_,F$))return["imm",this.parseExpr($,W+1)];if(E(_,s)&&$.length===W+2&&J.token==="op"&&/^[-+]+$/.test(J.str))return["add",{op:"sym",sym:":"+J.str}];else if($.length===W+1&&_.token==="op"&&/^[-+]+$/.test(_.str))return["add",{op:"sym",sym:_.str}];if(_.token=="ident"&&(_.str=="a"||_.str=="z")&&E(J,s)){let[Q,G]=this.parseArg($,W+2);if(Q=="acc"||Q=="imm")this.fail("Cannot force direct or absolute addressing on acc or imm arguments",_);let j=(_.str=="z"?r4:a4).get(Q);return[j?j:Q,G]}if(E(_,O0)||this.opts.allowBrackets&&E(_,Y$)){let Q=t($,W);if(Q<0)this.fail(`Unbalanced ${y(_)}`,_);let G=g($,W+1,Q);if(!G.length)this.fail("Bad argument",_);let X=this.parseExpr(G[0],0);if(G.length===1){if(E($[Q+1],H0)&&u0($[Q+2],"y"))return C($[Q+3]),["iny",X];return C($[Q+1]),["ind",X]}else if(G.length===2&&G[1].length===1){if(u0(G[1][0],"x"))return["inx",X]}this.fail("Bad argument",_)}let H=g($,W);if(!H.length)this.fail("Bad arg",_);let q=this.parseExpr(H[0],0);if(H.length===1)return["add",q];if(H.length===2&&H[1].length===1){if(u0(H[1][0],"x"))return["a,x",q];if(u0(H[1][0],"y"))return["a,y",q]}this.fail("Bad arg",_)}relative($,W,_){let J=this.chunk.data.length+W+1,H={rel:!0,chunk:this.chunks.length-1};if(this._chunk?.org)H.org=this._chunk.org;let Q={op:"-",args:[_,{op:"num",num:J,meta:H}]};if(_.source)Q.source=_.source;this.opcode($,W,Q)}opcode($,W,_){if(W)_=this.resolve(_);let{chunk:J}=this;if(this.markWritten(1+W),J.data.push($),W)this.append(_,W);if(!J.name)J.name="Code"}markWritten($){if(this._chunk?.org==null)return;let W=this.orgToOffset(this._chunk.org);if(W!=null)this.written.add(W+this._chunk.data.length,W+this._chunk.data.length+$)}append($,W){let{chunk:_}=this;if(this.opts.refExtractor?.ref&&_.org!=null){let H=this._exprMap?.get($)||$;if(u2(H).length>0)this.opts.refExtractor.ref(H,W,_.org+_.data.length,_.segments)}$=this.resolve($);let J=$.num;if($.op!=="num"||$.meta?.rel){let H=_.data.length;(_.subs||(_.subs=[])).push({offset:H,size:W,expr:$}),this.writeNumber(_.data,W)}else this.writeNumber(_.data,W,J)}org($,W){if(this._org!=null&&this._chunk!=null&&this._org+this._chunk.data.length===$)return;this._org=$,this._chunk=void 0,this._name=W}reloc($){this._org=void 0,this._chunk=void 0,this._name=$}segment(...$){this.segments=$.map((W)=>typeof W==="string"?W:W.name);for(let W of $)if(typeof W==="object"){let _=this.segmentData.get(W.name)||{name:W.name};this.segmentData.set(W.name,d0.merge(_,W))}this._chunk=void 0,this._name=void 0}assert($,W,_){$=this.resolve($);let J=this.evaluate($);if(J!=null){if(!J){let H="",q=this.chunk;if(q.org!=null)H=` (PC=$${(q.org+q.data.length).toString(16)})`;this.fail(`${_}
Assertion failed${H}`,$)}}else{let{chunk:H}=this;(H.asserts||(H.asserts=[])).push($)}}byte(...$){this.byteInternal($)}byteInternal($){let{chunk:W}=this;this.markWritten($.length);for(let _ of $)if(typeof _==="number")this.writeNumber(W.data,1,_);else if(typeof _==="string")o4(W.data,_);else this.append(_,1)}res($,W){if(!$)return;this.byte(...new Array($).fill(W??0))}word(...$){let{chunk:W}=this;this.markWritten(2*$.length);for(let _ of $)if(typeof _==="number")this.writeNumber(W.data,2,_);else this.append(_,2)}free($){if(this._org==null)this.fail(".free in .reloc mode");this.markWritten($);let W=this.segments.length>1?this.segments.filter((H)=>{let q=this.segmentData.get(H);if(!q||q.memory==null||q.size==null)return!1;if(q.memory>this._org)return!1;if(q.memory+q.size<=this._org)return!1;return!0}):this.segments;if(W.length!==1)this.fail(`.free with non-unique segment: ${this.segments}`);else if($<0)this.fail(`.free with negative size: ${$}`);if(this._chunk)this._org+=this._chunk.data.length;this._chunk=void 0;let _=W[0],J=this.segmentData.get(_);if(!J)this.segmentData.set(_,J={name:_});(J.free||(J.free=[])).push([this._org,this._org+$]),this._org+=$}segmentPrefix($){this._segmentPrefix=$}import(...$){for(let W of $)this.globals.set(W,"import")}export(...$){for(let W of $)this.globals.set(W,"export")}scope($){this.enterScope($,"scope")}proc($){this.label($),this.enterScope($,"proc")}enterScope($,W){let _=$?this.currentScope.children.get($):void 0;if(_){if(this.opts.reentrantScopes){this.currentScope=_;return}this.fail(`Cannot re-enter scope ${$}`)}let J=new d2(this.currentScope,W);if($)this.currentScope.children.set($,J);else this.currentScope.anonymousChildren.push(J);this.currentScope=J}endScope(){this.exitScope("scope")}endProc(){this.exitScope("proc")}exitScope($){if(this.currentScope.kind!==$||!this.currentScope.parent)this.fail(`.end${$} without .${$}`);this.currentScope=this.currentScope.parent}pushSeg(...$){if(this.segmentStack.push([this.segments,this._chunk]),$)this.segment(...$)}popSeg(){if(!this.segmentStack.length)this.fail(".popseg without .pushseg");[this.segments,this._chunk]=this.segmentStack.pop(),this._org=this._chunk?.org}move($,W){this.append({op:".move",args:[W],meta:{size:$}},$)}log($,W){let _=x(W[1],W[0]);if(C(W[2],"a single string"),$==="error")throw new Error(_);if($==="info")console.log(_);else console.warn(_)}parseConst($,W){let _=this.evaluate(this.parseExpr($,W));if(_!=null)return _;this.fail("Expression is not constant",$[1])}parseNoArgs($,W){C($[1])}parseExpr($,W){return e($,W,this.currentScope.symbols)}parseStr($,W){let _=x($[W]);return C($[W+1],"a single string"),_}parseSegmentList($,W,_){if($.length<W+1){if(_)return[];this.fail("Expected a segment list",$[W-1])}return g($,1).map((J)=>{let H=this._segmentPrefix+x(J[0]);if(J.length===1)return H;if(!E(J[1],s))this.fail(`Expected comma or colon: ${y(J[1])}`,J[1]);let q={name:H},Q=C$(J,1);for(let[G,X]of Q)switch(G){case"bank":q.bank=this.parseConst(X,0);break;case"size":q.size=this.parseConst(X,0);break;case"off":q.offset=this.parseConst(X,0);break;case"mem":q.memory=this.parseConst(X,0);break;case"fill":q.fill=this.parseConst(X,0);break;case"out":q.out=!0;break;case"overlay":q.overlay=this.parseStr(X,0);break;case"zp":q.addressing=1;break;default:this.fail(`Unknown segment attr: ${G}`)}if(q.offset===void 0&&q.size!==void 0)q.offset=this._segmentOffset,this._segmentOffset+=q.size;if(q.fill!==void 0&&q.size!==void 0)q.free=[[q.memory??0,(q.memory??0)+q.size]];return q})}parseResArgs($){let W=this.parseDataList($);if(W.length>2)this.fail("Expected at most 2 args",W[2]);if(!W.length)this.fail("Expected at least 1 arg");let _=this.evaluate(W[0]);if(_==null)this.fail("Expected constant count");let J=W[1]&&this.evaluate(W[1]);if(W[1]&&J==null)this.fail("Expected constant value");return[_,J]}parseDataList($,W=!1){if($.length<2)this.fail("Expected a data list",$[0]);let _=[];for(let J of g($,1))if(W&&J.length===1&&J[0].token==="str")_.push(J[0].str);else if(J.length<1)this.fail("Missing term");else _.push(this.resolve(this.parseExpr(J,0)));return _}parseIdentifierList($){if($.length<2)this.fail("Expected identifier(s)",$[0]);let W=[];for(let _ of g($,1)){if(_.length!==1||_[0].token!=="ident")this.fail(`Expected identifier: ${y(_[0])}`,_[0]);W.push(c0(_[0]))}return W}parseOptionalIdentifier($){let W=$[1];if(!W)return;let _=f(W);return C($[2]),_}parseRequiredIdentifier($){let W=f($[1]);return C($[2]),W}parseMoveArgs($){let W=g($,1);if(W.length!==2)this.fail("Expected constant number, then identifier");let _=this.evaluate(this.parseExpr(W[0],0));if(_==null)this.fail("Expected a constant number");let J=this.resolve(this.parseExpr(W[1],0));if(J.op==="num"&&J.meta?.chunk!=null)return[_,J];else this.fail("Expected a constant offset",W[1][0])}parseByteStr($){let W=x($[1]);C($[2]);let _=new l().decode(W);return Array.from(new Uint8Array(_))}parseAssert($){let W=g($,1);if(!W[0])this.fail("No assertion expression provided");let _=this.parseExpr(W[0],0),J=A$(W.at(1)?.at(0))??"error",H=K$(W.at(2)?.at(0))??"Assertion failed";return[_,J,H]}fail($,W){if(!W&&this.errorToken)W=this.errorToken;if(W?.source)throw new Error($+v(W));if(!this._source&&this._chunk?.name)throw new Error($+`
  in ${this._chunk.name}`);throw new Error($+v({source:this._source}))}writeNumber($,W,_){for(let J=0;J<W;J++)if($.push(_!=null?_&255:255),_!=null)_>>=8}orgToOffset($){let W=this.segmentData.get(this.segments.find((_)=>{let J=this.segmentData.get(_);return J&&d0.includesOrg(J,$)}));return W?.offset!=null?W.offset+($-W.memory):void 0}isWritten($){return this.written.has($)}}function o4($,W){for(let _=0;_<W.length;_++)$.push(W.charCodeAt(_))}function n4($){if($==="*")return{type:"pc"};if(/^:\++$/.test($))return{type:"anon",num:$.length-1};if(/^:\+\d+$/.test($))return{type:"anon",num:parseInt($.substring(2))};if(/^:-+$/.test($))return{type:"anon",num:1-$.length};if(/^:-\d+$/.test($))return{type:"anon",num:-parseInt($.substring(2))};if(/^:>*rts$/.test($))return{type:"rts",num:Math.max($.length-4,1)};if(/^:<+rts$/.test($))return{type:"rts",num:4-$.length};if(/^\++$/.test($))return{type:"rel",num:$.length};if(/^-+$/.test($))return{type:"rel",num:-$.length};return{type:"none"}}var r4=new Map([["add","zpg"],["a,x","zpx"],["a,y","zpy"],["abs","zpg"],["abx","zpx"],["aby","zpy"]]),a4=new Map([["add","abs"],["a,x","abx"],["a,y","aby"],["zpg","abs"],["zpx","abx"],["zpy","aby"]]);var s4={segments:[{name:"code",default:!0,offset:0,size:64768,memory:512,free:[[512,64768]]}]},t4={segments:[{name:"header",size:16,offset:0,memory:0},{name:"code",default:!0,size:32768,offset:16,memory:32768,free:[[32768,65536]]},{name:"chr",size:8192,offset:32784,memory:0}]},m$=new Map([["sim",s4],["nes-nrom",t4]]);var p$=J8(l$(),1);var e4=!1;class p0{overloads;constructor($){this.overloads=$}canOverload(){return this.overloads[this.overloads.length-1].canOverload()}append($){if(!this.canOverload()){let W=this.overloads[this.overloads.length-1].definition,J=(W?v(W):"").replace(/at/,"previously defined at"),H=$.overloads[0].definition,q=H?F(H):"";throw new Error(`Non-overloadable: ${q}${J}`)}this.overloads.push(...$.overloads)}expand($,W){let _=[];for(let J of this.overloads){let H=J.expand($,W);if(Array.isArray(H))return H;_.push(H)}if(e4)console.error(_.join(`
`));return}static from($){if(!E($[0],R$))throw new Error("invalid");if($[1]?.token!=="ident")throw new Error("invalid");let W=$[2],_;if(!W)_=new E2([],[],$[1]);else if(W.token==="grp")_=new E2(W.inner,$.slice(3),$[1]);else if(W.token==="lp"){let J=t($,2);if(J<0)throw new Error(`Expected close paren ${F($[2])}`);_=new c$(e0($.slice(3,J)),$.slice(J+1),$[1])}else _=new E2([],$.slice(2),$[1]);return new p0([_])}}function u$($,W,_,J,H){let q=[],Q=[],G=q;for(let X of H){if(X.token==="ident"){let M=J.get(X.str);if(M){G.push(...M);continue}}else if(E(X,z2)){Q.push(G=[]);continue}let j=X.source&&$[0].source?{...X.source,parent:$[0].source}:X.source||$[0].source;G.push(j?{...X,source:j}:X)}if(Q=Q.filter((X)=>X.length),Q.length&&_<$.length)return"cannot expand .eol without consuming to end of line";return $.splice(W,_-W,...q),Q}class c${params;production;definition;constructor($,W,_){this.params=$;this.production=W;this.definition=_}expand($,W){let _=W+1,J=this.params.length?$.length:W,H=J,q=new Map;if(W<$.length&&E(O0,$[_])){if(H=t($,_),H<0)return"missing close paren for enclosed C-style expansion";J=H+1,_++}let Q=g($,_,H);if(Q.length>this.params.length)return"too many args";for(_=0;_<this.params.length;_++){let G=Q[_]||[],X=G[0];if(G.length===1&&X.token==="grp")G=X.inner;q.set(this.params[_],G)}return u$($,W,J,q,this.production)}canOverload(){return Boolean(this.params.length)}}class E2{pattern;production;definition;constructor($,W,_){this.pattern=$;this.production=W;this.definition=_}expand($,W){let _=W+1,J=new Map;for(let H=0;H<this.pattern.length;H++){let q=this.pattern[H];if(q.token==="ident"){let Q=this.pattern[H+1];if(!Q||Q?.token==="ident"){let G=$[_++];if(!G)return`missing undelimited argument ${y(q)}`;J.set(q.str,G.token==="grp"?G.inner:[G])}else{let G=E(Q,z2)?$.length:k2($,Q,_);if(G<0)return`could not find delimiter ${y(Q)}`;J.set(q.str,$.slice(_,G)),_=G}}else if(E(q,z2)){if(_<$.length)return"could not match .eol"}else if(!E($[_++],q))return`could not match: ${y(q)}`}return u$($,W,_,J,this.production)}canOverload(){return Boolean(this.pattern.length)}}class J2{params;production;constructor($,W){this.params=$;this.production=W}static async from($,W){if(!E($[0],U$))throw new Error("invalid");if($[1]?.token!=="ident")throw new Error("invalid");let _=e0($.slice(2)),J=[],H;while(H=await W.next()){if(E(H[0],B$))return new J2(_,J);J.push(H)}throw new Error(`EOF looking for .endmacro: ${F($[1])}`)}expand($,W){let _=1,J=new Map,H=[];for(let Q of this.params){let G=P$($,_),X=$.slice(_,G);if(_=G+1,X.length===1&&X[0].token==="grp")X=X[0].inner;J.set(Q,X)}if(_<$.length)throw new Error(`Too many macro parameters: ${F($[_])}`);let q=new Map;for(let Q of this.production){if(E(Q[0],y2)){let X=e0(Q.slice(1));for(let j of X)q.set(j,`${j}@${W.next()}`)}let G=(X)=>{let j=[];for(let M of X){if(E(M,y2))return j;if(M.token==="ident"){let K=J.get(M.str);if(K){j.push(...K);continue}let A=q.get(M.str);if(A){j.push({token:"ident",str:A});continue}}else if(M.token==="grp"){j.push({token:"grp",inner:G(M.inner)});continue}let O=M.source&&$[0].source?{...M.source,parent:$[0].source}:M.source||$[0].source;j.push(O?{...M,source:O}:M)}return j};H.push(G(Q))}return H.filter((Q)=>Q.length!=0)}}var $6=100,d$=new WeakMap;function W6($){let W=d$.get($);if(!W)d$.set($,W=((_)=>({next:()=>_++}))(0));return W}class H2{stream;env;macros;sink;repeats=[];constructor($,W,_){this.stream=$;this.env=W;this.macros=_?_.macros:new Map}async tokens(){let $=[],W;while(W=await this.next())$.push(W);return $}async next(){while(!0){if(!this.sink)this.sink=await this.pump();let{value:$,done:W}=await this.sink.next();if(!W)return $;this.sink=void 0}}async*pump(){let $=await this.readLine();if($==null)return void(yield $);while($.length){let W=$[0];switch(W.token){case"ident":if(E($[1],s)){yield $.splice(0,2);break}if(E($[1],R2))this.env.assignSym($);else if(E($[1],w2))this.env.setSym($);if(!this.tryExpandMacro($))yield $;return;case"cs":if(!await this.tryRunDirective($))yield $;return;case"op":if(/^[-+]+$/.test(W.str)){let _=[W],J=$[1];if(J&&E(J,s))_.push(J),$.splice(0,2);else _.push({token:"op",str:":"}),$.splice(0,1);yield _;break}else if(W.str===":"){yield $.splice(0,1);break}default:throw new Error(`Unexpected: ${F($[0])}`)}}}async readLine(){let $=await this.stream.next();if($==null)return $;return this.expandLine($)}expandLine($,W=0){let _=$[0],J=0,H=0;while(W<$.length){if(W>H)H=W,J=0;else if(J++>$6)throw new Error(`Maximum expansion depth reached: ${$.map(y).join(" ")}${v(_)}`);W=this.expandToken($,W)}return $}expandToken($,W){let _=$[W];if(_.token==="ident"){let J=this.macros.get(_.str);if(J instanceof p0){let H=J.expand($,W);if(H){if(H.length)this.stream.unshift(...H);return W}}}else if(_.token==="cs")return this.expandDirective(_.str,$,W);return W+1}tryExpandMacro($){let[W]=$;if(W.token!=="ident")throw new Error("impossible");let _=this.macros.get(W.str);if(!(_ instanceof J2))return!1;let J=_.expand($,W6(this.env));return this.stream.enter(),this.stream.unshift(...J),!0}expandDirective($,W,_){switch($){case".define":case".ifdef":case".ifndef":case".undefine":return this.skipIdentifier(W,_);case".skip":return this.skip(W,_);case".noexpand":return this.noexpand(W,_);case".tcount":return this.parseArgs(W,_,1,this.tcount);case".ident":return this.parseArgs(W,_,1,this.ident);case".string":return this.parseArgs(W,_,1,this.string);case".concat":return this.parseArgs(W,_,0,this.concat);case".sprintf":return this.parseArgs(W,_,0,this.sprintf);case".cond":return this.parseArgs(W,_,0,this.cond);case".blank":return this.parseArgs(W,_,1,this.blank);case".defined":return this.parseArgs(W,_,1,this.definedSymbol);case".definedsymbol":return this.parseArgs(W,_,1,this.definedSymbol);case".constantsymbol":return this.parseArgs(W,_,1,this.constantSymbol);case".referencedsymbol":return this.parseArgs(W,_,1,this.referencedSymbol)}return _+1}skip($,W){$.splice(W,1);let _=$[W];if(_?.token==="grp")this.expandToken(_.inner,0);else this.expandToken($,W+1);return W}noexpand($,W){let _=$[W+1];if(_.token==="grp")$.splice(W,2,..._.inner),W+=_.inner.length-1;else $.splice(W,1);return W+1}parseArgs($,W,_,J){let H=$[W];D$(O0,$[W+1],H);let q=t($,W+1),Q=g($,W+2,q).map((X)=>{if(X.length===1&&X[0].token==="grp")X=X[0].inner;return this.expandLine(X)});if(_&&Q.length!==_)throw new Error(`Expected ${_} parameters: ${F(H)}`);let G=J.call(this,H,...Q);return $.splice(W,q+1-W,...G),W}tcount($,W){return[{token:"num",num:m2(W),source:$.source}]}ident($,W){let _=x(W[0],$);return C(W[1],"a single token"),[{token:"ident",str:_,source:W[0].source}]}string($,W){let _=f(W[0],$);return C(W[1],"a single token"),[{token:"str",str:_,source:W[0].source}]}concat($,...W){return[{token:"str",str:W.map((J)=>{let H=x(J[0]);return C(J[1],"a single string"),H}).join(""),source:$.source}]}sprintf($,W,..._){let J=/^%(%|-?0?\d*(\.\d+)?[diouXxsc])/,H=x(W[0],$),q="",Q=[],G=W.slice(-1)[0],X=0,j=0;while(X<H.length){let M=H.indexOf("%",X);if(M<0)M=H.length;if(M!=X)q+=H.slice(X,M),X=M;else{let O=J.exec(H.substring(X));if(!O)throw new Error("invalid format string");let K=O[0].slice(-1);if(K!="%"){let A=_[j],B=0;if(K=="s")B=x(A[0],G);else B=this.evaluateConst(L2(A,G));Q.push(B),j++,G=A.slice(-1)[0]}q+=O[0],X+=O[0].length}}return[{token:"str",str:p$.vsprintf(q,Q),source:$.source}]}cond($,...W){throw new Error("unimplemented")}blank($,W){return[{token:"num",num:W.length===0?1:0}]}definedSymbol($,W){let _=f(W[0],$);return C(W[1],"a single identifier"),[{token:"num",num:this.env.definedSymbol(_)?1:0}]}constantSymbol($,W){let _=f(W[0],$);return C(W[1],"a single identifier"),[{token:"num",num:this.env.constantSymbol(_)?1:0}]}referencedSymbol($,W){let _=f(W[0],$);return C(W[1],"a single identifier"),[{token:"num",num:this.env.referencedSymbol(_)?1:0}]}skipIdentifier($,W){return $[W+1]?.token==="ident"?W+2:W+1}async tryRunDirective($){let W=$[0];if(W.token!=="cs")throw new Error("impossible");let _=this.runDirectives[W.str];if(!_)return!1;return await _($),!0}evaluateConst($){if($=h$($,(J)=>{if(J.op==="sym"&&this.env.definedSymbol(J.sym)){let H=this.env.evaluate(J);if(H===void 0)throw new Error(`Symbol ${J.sym} is undefined`);return Z({op:"num",num:H,meta:o(H,void 0)})}return Z(J)}),$.op==="num"&&!$.meta?.rel)return $.num;let _=v($);throw new Error(`Expected a constant: ${_} : ${$}`)}runDirectives={".define":($)=>this.parseDefine($),".undefine":($)=>this.parseUndefine($),".else":([$])=>U2(".if",$),".elseif":([$])=>U2(".if",$),".endif":([$])=>U2(".if",$),".endmacro":([$])=>U2(".macro",$),".endrepeat":($)=>this.parseEndRepeat($),".exitmacro":async([,$])=>{return _6($),this.stream.exit(),await Promise.resolve()},".if":([$,...W])=>this.parseIf(!!this.evaluateConst(L2(W,$))),".ifdef":([$,...W])=>this.parseIf(this.parseIfDef(W,$)),".ifndef":([$,...W])=>this.parseIf(!this.parseIfDef(W,$)),".ifblank":([,...$])=>this.parseIf(!$.length),".ifnblank":([,...$])=>this.parseIf(!!$.length),".ifref":([$,...W])=>this.parseIf(this.env.referencedSymbol(z0(W,$))),".ifnref":([$,...W])=>this.parseIf(!this.env.referencedSymbol(z0(W,$))),".ifsym":([$,...W])=>this.parseIf(this.env.definedSymbol(z0(W,$))),".ifnsym":([$,...W])=>this.parseIf(!this.env.definedSymbol(z0(W,$))),".ifconst":([$,...W])=>this.parseIf(this.env.constantSymbol(z0(W,$))),".ifnconst":([$,...W])=>this.parseIf(!this.env.constantSymbol(z0(W,$))),".ifp02":([$,...W])=>this.parseIf(!0),".ifp4510":([$,...W])=>this.parseIf(!1),".ifp816":([$,...W])=>this.parseIf(!1),".ifpc02":([$,...W])=>this.parseIf(!1),".ifpdtv":([$,...W])=>this.parseIf(!1),".ifpsc02":([$,...W])=>this.parseIf(!1),".macro":($)=>this.parseMacro($),".repeat":($)=>this.parseRepeat($)};async parseDefine($){let W=f($[1],$[0]),_=p0.from($),J=this.macros.get(W);if(J instanceof p0)J.append(_);else if(J)throw new Error(`Already defined: ${W}`);else this.macros.set(W,_);return await Promise.resolve()}async parseUndefine($){let[W,_,J]=$,H=f(_,W);if(C(J),!this.macros.has(H))throw new Error(`Not defined: ${F(_)}`);return this.macros.delete(H),await Promise.resolve()}async parseMacro($){let W=f($[1],$[0]),_=await J2.from($,this.stream);if(this.macros.get(W))throw new Error(`Already defined: ${W}`);this.macros.set(W,_)}async parseRepeat($){let[W,_]=V2($,1),J=$[1]||$[0];if(!W)throw new Error(`Expected expression: ${F(J)}`);let H=this.evaluateConst(W);if(H==null)throw new Error(`Expected a constant${v(W)}`);let q;if(_<$.length){if(!E($[_],H0))throw new Error(`Expected comma: ${F($[_])}`);q=f($[_+1]),C($[_+2])}let Q=[],G=1;while(G>0){if($=await this.stream.next()??J6(".repeat with no .endrep"),E($[0],L$))G++;if(E($[0],E$))G--;Q.push($)}this.repeats.push([Q,H,-1,q]),this.parseEndRepeat($)}async parseEndRepeat($){C($[1]);let W=this.repeats.pop();if(!W)throw new Error(`.endrep with no .repeat${v($[0])}`);if(++W[2]>=W[1])return await Promise.resolve();return this.repeats.push(W),this.stream.unshift(...W[0].map((_)=>_.map((J)=>{if(J.token!=="ident"||J.str!==W[3])return J;let H={token:"num",num:W[2]};if(J.source)H.source=J.source;return H}))),await Promise.resolve()}async parseIf($){let W=1,_=!1,J=[];while(W>0){let H=await this.stream.next();if(!H)throw new Error("EOF looking for .endif");let q=H[0];if(E(q,V$)){if(W--,!W)break}else if(q.token==="cs"&&q.str.startsWith(".if"))W++;else if(W===1&&!_){if($&&(E(q,g2)||E(q,Z2))){$=!1,_=!0;continue}else if(E(q,Z2)){$=!!this.evaluateConst(L2(this.expandLine(H.slice(1)),q));continue}else if(E(q,g2)){$=!0;continue}}if($)J.push(H)}this.stream.unshift(...J)}parseIfDef($,W){return this.macros.has(z0($,W))||this.env.definedSymbol(z0($,W))}}function z0($,W){let _=L2($,W);return g$(_)}function L2($,W){if(!$.length){if(!W)throw new Error("Expected expression");throw new Error(`Expected expression: ${F(W)}`)}return e($)}function _6($){if($)throw new Error(`garbage at end of line: ${F($)}`)}function U2($,W){throw new Error(`${y(W)} with no ${$}${v(W)}`)}function J6($){throw new Error($)}var i$=`
;;; Tag for labels that we expect to override vanilla
.define OVERRIDE

;;; Nicer syntax for declaring free sections
.define FREE {seg [start, end)}     .pushseg seg .eol     .org start .eol     .free end - start .eol     .popseg
.define FREE {seg [start, end]} .noexpand FREE seg [start, end + 1)


;;; Relocate a block of code and update refs
;;; Usage:
;;;   RELOCATE segments [start, end) refs...
;;; Where |segments| is an optional comma-separated list of segment
;;; names, and |refs| is a space-separated list of addresses whose
;;; contents point to |start| and that need to be updated to point to
;;; whereever it eventually ended up.  If no segments are specified
;;; then the relocation will stay within the current segment.
.define RELOCATE {seg [start, end) refs .eol} .org start .eol : FREE_UNTIL end .eol .ifnblank seg .eol .pushseg seg .eol .endif .eol .reloc .eol : .move (end-start), :-- .eol .ifnblank seg .eol .popseg .eol .endif .eol UPDATE_REFS :- @ refs

;;; Update a handful of refs to point to the given address.
;;; Usage:
;;;   UPDATE_REFS target @ refs...
;;; Where |refs| is a space-separated list of addresses, and
;;; |target| is an address or label to insert into each ref.
.define UPDATE_REFS {target @ ref refs .eol} .org ref .eol   .word (target) .eol UPDATE_REFS target @ refs
.define UPDATE_REFS {target @ .eol}


.macro FREE_UNTIL end
  .assert * <= end
  .free end - *
.endmacro

`;var o$=`
; Original from cc65
; This software is provided 'as-is', without any express or implied warranty.
; In no event will the authors be held liable for any damages arising from
; the use of this software.

; Permission is granted to anyone to use this software for any purpose,
; including commercial applications, and to alter it and redistribute it
; freely, subject to the following restrictions:

; 1. The origin of this software must not be misrepresented; you must not
; claim that you wrote the original software. If you use this software in
; a product, an acknowledgment in the product documentation would be
; appreciated but is not required.

; 2. Altered source versions must be plainly marked as such, and must not
; be misrepresented as being the original software.

; 3. This notice may not be removed or altered from any source distribution.


; add - Add without carry
.macro  add     Arg1, Arg2
        clc
        .if .paramcount = 2
                adc     Arg1, Arg2
        .else
                adc     Arg1
        .endif
.endmacro

; sub - subtract without borrow
.macro  sub     Arg1, Arg2
        sec
        .if .paramcount = 2
                sbc     Arg1, Arg2
        .else
                sbc     Arg1
        .endif
.endmacro

; bge - jump if unsigned greater or equal
.macro  bge     Arg
        bcs     Arg
.endmacro

; blt - Jump if unsigned less
.macro  blt     Arg
        bcc     Arg
.endmacro

; bgt - jump if unsigned greater
.macro  bgt     Arg
        .local  L
        beq     L
        bcs     Arg
L:
.endmacro

; ble - jump if unsigned less or equal
.macro  ble     Arg
        beq     Arg
        bcc     Arg
.endmacro

; bnz - jump if not zero
.macro  bnz     Arg
        bne     Arg
.endmacro

; bze - jump if zero
.macro  bze     Arg
        beq     Arg
.endmacro

`;var n$=`
; Original from cc65
; This software is provided 'as-is', without any express or implied warranty.
; In no event will the authors be held liable for any damages arising from
; the use of this software.

; Permission is granted to anyone to use this software for any purpose,
; including commercial applications, and to alter it and redistribute it
; freely, subject to the following restrictions:

; 1. The origin of this software must not be misrepresented; you must not
; claim that you wrote the original software. If you use this software in
; a product, an acknowledgment in the product documentation would be
; appreciated but is not required.

; 2. Altered source versions must be plainly marked as such, and must not
; be misrepresented as being the original software.

; 3. This notice may not be removed or altered from any source distribution.

.macro  jeq     Target
        .if     .match(Target, 0)
        bne     *+5
        jmp     Target
        .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
                beq     Target
        .else
                bne     *+5
                jmp     Target
        .endif
.endmacro
.macro  jne     Target
        .if     .match(Target, 0)
                beq     *+5
                jmp     Target
        .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
                bne     Target
        .else
                beq     *+5
                jmp     Target
        .endif
.endmacro
.macro  jmi     Target
        .if     .match(Target, 0)
                bpl     *+5
                jmp     Target
        .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
                bmi     Target
        .else
                bpl     *+5
                jmp     Target
        .endif
.endmacro
.macro  jpl     Target
        .if     .match(Target, 0)
                bmi     *+5
                jmp     Target
        .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
                bpl     Target
        .else
                bmi     *+5
                jmp     Target
        .endif
.endmacro
.macro  jcs     Target
        .if     .match(Target, 0)
                bcc     *+5
                jmp     Target
        .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
                bcs     Target
        .else
                bcc     *+5
                jmp     Target
        .endif
.endmacro
.macro  jcc     Target
        .if     .match(Target, 0)
                bcs     *+5
                jmp     Target
        .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
                bcc     Target
        .else
                bcs     *+5
                jmp     Target
        .endif
.endmacro
.macro  jvs     Target
        .if     .match(Target, 0)
                bvc     *+5
                jmp     Target
        .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
                bvs     Target
        .else
                bvc     *+5
                jmp     Target
        .endif
.endmacro
.macro  jvc     Target
        .if     .match(Target, 0)
                bvs     *+5
                jmp     Target
        .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
                bvc     Target
        .else
                bvs     *+5
                jmp     Target
        .endif
.endmacro

`;var r$=`
; Original from nesdev wiki: https://www.nesdev.org/wiki/NES_2.0_header_for_ca65
;
; NES 2.0 header generator for ca65 (nes2header.inc)
; 
; Copyright 2016 Damian Yerrick
; Copying and distribution of this file, with or without
; modification, are permitted in any medium without royalty provided
; the copyright notice and this notice are preserved in all source
; code copies.  This file is offered as-is, without any warranty.
;
; Modified to add a segment_name parameter for the header to nes2end

;;
; Puts ceil(log2(sz / 64)) in logsz, which should be
; local to the calling macro.  Used for NES 2 RAM sizes.
.macro _nes2_logsize sz, logsz
  .assert sz >= 0 .and sz <= 1048576, error, "RAM size must be 0 to 1048576"
  .if sz < 1
    logsz = 0
  .elseif sz <= 128
    logsz = 1
  .elseif sz <= 256
    logsz = 2
  .elseif sz <= 512
    logsz = 3
  .elseif sz <= 1024
    logsz = 4
  .elseif sz <= 2048
    logsz = 5
  .elseif sz <= 4096
    logsz = 6
  .elseif sz <= 8192
    logsz = 7
  .elseif sz <= 16384
    logsz = 8
  .elseif sz <= 32768
    logsz = 9
  .elseif sz <= 65536
    logsz = 10
  .elseif sz <= 131072
    logsz = 11
  .elseif sz <= 262144
    logsz = 12
  .elseif sz <= 524288
    logsz = 13
  .else
    logsz = 14
  .endif
.endmacro

;;
; Sets the PRG ROM size to sz bytes. Must be multiple of 16384;
; should be a power of 2.
; example: nes2prg 131072
.macro nes2prg sz
.local sz1
  sz1 = (sz) / 16384
_nes2_prgsize = <sz1
_nes2_prgsizehi = >sz1
.endmacro

;;
; Sets the CHR ROM size to sz bytes. Must be multiple of 8192;
; should be a power of 2.
; example: nes2chr 32768
.macro nes2chr sz
.local sz1
  sz1 = (sz) / 8192
_nes2_chrsize = <sz1
_nes2_chrsizehi = >sz1
.endmacro

;;
; Sets the (not battery-backed) work RAM size in bytes.
; Default is 0.
.macro nes2wram sz
.local logsz
  _nes2_logsize sz, logsz
  _nes2_wramsize = logsz
.endmacro

;;
; Sets the battery-backed work RAM size in bytes.  Default is 0.
.macro nes2bram sz
.local logsz
  _nes2_logsize sz, logsz
  _nes2_bramsize = logsz
.endmacro

;;
; Sets the (not battery-backed) CHR RAM size in bytes.  Default is 0
; if CHR ROM or battery-backed CHR RAM is defined; otherwise 8192.
.macro nes2chrram sz
.local logsz
  _nes2_logsize sz, logsz
  _nes2_chrramsize = logsz
.endmacro

;;
; Sets the battery-backed CHR RAM size in bytes.  Default is 0.
.macro nes2chrbram sz
.local logsz
  _nes2_logsize sz, logsz
  _nes2_chrbramsize = logsz
.endmacro

;;
; Sets the mirroring to one of these values:
; 'H' (horizontal mirroring, vertical arrangement)
; 'V' (vertical mirroring, horizontal arrangement)
; '4' (four-screen VRAM)
; 218 (four-screen and vertical bits on, primarily for mapper 218)
.macro nes2mirror mir
.local mi1
  mi1 = mir
  .if mi1 = 'h' .or mi1 = 'H'
    _nes2_mirror = 0
  .elseif mi1 = 'v' .or mi1 = 'V'
    _nes2_mirror = 1
  .elseif mi1 = '4'
    _nes2_mirror = 8
  .elseif mi1 = 218
    _nes2_mirror = 9
  .else
    .assert 0, error, "Mirroring mode must be 'H', 'V', or '4'"
  .endif
.endmacro

;;
; Sets the mapper (board class) ID.  For example, MMC3 is usually
; mapper 4, but TLSROM is 118 and TQROM is 119.  Some mappers have
; variants.
.macro nes2mapper mapperid, submapper
.local mi1, ms1
  mi1 = mapperid
  .assert mi1 >= 0 .and mi1 < 4096, error, "Mapper must be 0 to 4095"
  .ifnblank submapper
    .assert ms1 >= 0 .and ms1 < 16, error, "Submapper must be 0 to 15"
    ms1 = submapper
  .else
    ms1 = 0
  .endif
  _nes2_mapper6 = (mi1 & $0F) << 4
  _nes2_mapper7 = mi1 & $F0
  _nes2_mapper8 = (mi1 >> 8) | (ms1 << 4)
.endmacro

;;
; Sets the ROM's intended TV system:
; 'N' for NTSC NES/FC/PC10
; 'P' for PAL NES
; 'N','P' for dual compatible, preferring NTSC
; 'P','N' for dual compatible, preferring PAL NES
.macro nes2tv tvsystem, dual_compatible
.local tv1, tv2
  tv1 = tvsystem
  .ifnblank dual_compatible
    tv2 = $02
  .else
    tv2 = $00
  .endif
  .if tv1 = 'n' .or tv1 = 'N'
    _nes2_tvsystem = $00 | tv2
  .elseif tv1 = 'p' .or tv1 = 'P'
    _nes2_tvsystem = $01 | tv2
  .else
    .assert 0, error, "TV system must be 'N' or 'P'"
  .endif
.endmacro

;;
; Writes the header configured by previous nes2 macros.
.macro nes2end header_segment
.local battery_bit
  ; Apply defaults
  .ifndef _nes2_chrsize
    nes2chr 0
  .endif
  .ifndef _nes2_mirror
    nes2mirror 'H'
  .endif
  .ifndef _nes2_wramsize
    nes2wram 0
  .endif
  .ifndef _nes2_bramsize
    nes2bram 0
  .endif
  .ifndef _nes2_chrbramsize
    nes2chrbram 0
  .endif
  .ifndef _nes2_chrramsize
    .if _nes2_chrsize .or _nes2_chrsizehi .or _nes2_chrbramsize
      nes2chrram 0
    .else
      nes2chrram 8192
    .endif
  .endif
  .ifndef _nes2_tvsystem
    nes2tv 'N'
  .endif
  .if _nes2_bramsize .or _nes2_chrbramsize
    battery_bit = $02
  .else
    battery_bit = $00
  .endif

.pushseg
  .segment header_segment
  .byte "NES",$1A
  .byte _nes2_prgsize, _nes2_chrsize
  .byte _nes2_mapper6 | _nes2_mirror | battery_bit
  .byte _nes2_mapper7 | $08  ; not supporting vs/pc10 yet

  .byte _nes2_mapper8
  .byte (_nes2_chrsizehi << 4) | _nes2_prgsizehi
  .byte (_nes2_bramsize << 4) | _nes2_wramsize
  .byte (_nes2_chrbramsize << 4) | _nes2_chrramsize

  .byte _nes2_tvsystem, 0, 0, 0
.popseg
.endmacro

`;var G6=100,M6=new Map([["common",i$],["generic",o$],["longbranch",n$],["nes2header",r$]]);class q2{readFile;readFileBinary;opts;stack=[];constructor($,W,_){this.readFile=$;this.readFileBinary=W;this.opts=_}loadFile($,W){let _=this.opts?.includePaths??["./"];for(let J of _)try{return W(J,$)}catch(H){}throw new Error(`Could not find file ${$} in include directories: ${_.join(",")}`)}async next(){while(this.stack.length){let[$,W]=this.stack[this.stack.length-1];if(W.length)return W.pop();let _=await $?.next();if(_){if(_?.[0].token!=="cs")return _;switch(_[0].str){case".include":{let J=this.str(_);if(!this.readFile)this.err(_);let H=await this.loadFile(J,this.readFile);this.enter(new $0(H,J,this.opts));continue}case".macpack":{let J=f(_[1])?.toLowerCase(),H=M6.get(J)??this.err(_);this.enter(new $0(H,`${J}.macpack`,this.opts));continue}case".incbin":{if(!this.readFileBinary)this.err(_);if(_.length<1)this.err(_);let J=x(_[1],_[0]),H=0,q=void 0;if(_.length>2){let M=g(_,2);if(M[1])H=Z(e(M[1])).num??0;if(M[2])q=Z(e(M[2])).num??-1}let Q=await this.loadFile(J,this.readFileBinary);Q=typeof Q==="string"?new l().decode(Q):Q;let G=q!==void 0?H+q:void 0,X=new l().encode(Q.slice(H,G));return[O$,{token:"str",str:X}]}default:return _}}this.stack.pop()}return}unshift(...$){if(!this.stack.length)throw new Error("Cannot unshift after EOF");let W=this.stack[this.stack.length-1][1];for(let _=$.length-1;_>=0;_--)W.push($[_])}enter($){let W=[void 0,[]];if($)W[0]=$;if(this.stack.push(W),this.stack.length>G6)throw new Error("Stack overflow")}exit(){this.stack.pop()}err($){let W=this.str($);throw new Error(W+v($[0]))}str($){let W=x($[1],$[0]);return C($[2],"a single string"),W}}class Q2{opts;static assemble($){let W={lineContinuations:!0},_=new $0($,"contents.s",W),J=new _2(w0.P02),H=new q2(void 0,void 0,W);H.enter(_);let q=new H2(H,J);J.tokens(q);let Q=new Q2;Q.read(J.module());let G=Q.link(),X=new Uint8Array(G.length);return G.apply(X),X}static link(...$){let W=new Q2;for(let _ of $)W.read(_);return W.link()}_link=new t$;_exports;constructor($={}){this.opts=$}read($){return this._link.readFile($),this}base($,W=0){return this._link.base($,W),this}link(){let $=m$.get(this.opts.target?.toLowerCase());if($)$.segments.forEach((W)=>this._link.addRawSegment(W));return this._link.link()}report($=!1){console.log(this._link.report($))}exports(){if(this._exports)return this._exports;return this._exports=this._link.buildExports()}watch(...$){this._link.watches.push(...$)}}function F0($){throw new Error($)}class a${name;bank;size;offset;memory;addressing;fill;constructor($){let W=this.name=$.name;this.bank=$.bank??0,this.addressing=$.addressing??2,this.size=$.size??F0(`Size must be specified: ${W}`),this.offset=$.offset??F0(`Offset must be specified: ${W}`),this.memory=$.memory??0,this.fill=$.fill??0}get delta(){return this.offset-this.memory}}class s${linker;index;name;size;segments;asserts;subs=new Set;selfSubs=new Set;deps=new Set;imports=new Set;follow=new Map;overlaps=!1;_data;_org;_offset;_segment;_overwrite;constructor($,W,_,J,H){this.linker=$;this.index=W;this.name=_.name,this.size=_.data.length,this.segments=_.segments,this._data=_.data;for(let q of _.subs||[])this.subs.add(j6(q,J,H));if(this.asserts=(_.asserts||[]).map((q)=>O2(q,J,H)),_.org)this._org=_.org;this._overwrite=_.overwrite||"allow"}get org(){return this._org}get offset(){return this._offset}get segment(){return this._segment}get data(){return this._data??F0("no data")}initialPlacement(){if(this._org==null)return;let $=[];for(let _ of this.segments){let J=this.linker.segments.get(_);if(!J)throw new Error(`Unknown segment: ${_}`);if(this._org>=J.memory&&this._org<J.memory+J.size)$.push(J)}if($.length!==1)throw new Error(`Non-unique segment for ${this.name}:
Segments: ${this.segments.join(",")}, org: $${this.org?.toString(16)}, offset: $${this.offset?.toString(16)}
Eligible: [${$}]`);let W=$[0];if(this._org>=W.memory+W.size)throw new Error(`Chunk does not fit in segment ${W.name}`);this.place(this._org,W,this._overwrite)}place($,W,_){this._org=$,this._segment=W;let J=this._offset=$+W.delta;for(let Q of this.linker.watches)if(Q>=J&&Q<J+this.size)F0("Unable to place");I2(this.linker.placed,(Q)=>Q[0],[J,this]);let H=this.linker.data,q=this._data??F0("No data");if(this._data=void 0,this.subs.size){H.splice(J,q.length);let Q=new L0;Q.set(0,q);for(let G of this.subs)Q.splice(G.offset,G.size);for(let[G,X]of Q.chunks())H.set(J+G,...X)}else H.set(J,q);if(_&&q.length){let Q=!1,[G]=this.linker.written.tail(J);if(G?.[0]<=J&&G[1]>=J+q.length)Q=!0;else if(G?.[0]<J+q.length)Q=null;let X="";if(_==="require"&&Q!==!0)X=`required to overwrite ${q.length} bytes but did not.`;else if(_==="forbid"&&Q!==!1)X=`forbidden to overwrite ${q.length} but did anyway.`;if(X){if(X=`Chunk at ${W.name}:$${$.toString(16).padStart(4,"0")} (offset $${J.toString(16).padStart(5,"0")} was ${X}`,!z6)throw new Error(X);if(!w6)console.error(X)}this.linker.written.add(J,J+q.length)}for(let[Q,G]of this.follow)G.resolveSub(Q,!1);this.linker.free.delete(this.offset,this.offset+this.size)}resolveSubs($=!1){for(let W of this.selfSubs)this.resolveSub(W,$);for(let W of this.subs)this.resolveSub(W,$)}addDep($,W){if(W===this.index&&this.subs.delete($))this.selfSubs.add($);this.linker.chunks[W].follow.set($,this),this.deps.add(W)}resolveSub($,W){if(!this.subs.has($)&&!this.selfSubs.has($))return;$.expr=Y0($.expr,(J,H,q)=>{if(W&&q?.op==="^"&&q.args.length===1&&J.meta){if(J.meta.bank==null)this.addDep($,J.meta.chunk);return J}if(J=this.linker.resolveLink(Z(H(J))),W&&J.meta?.rel)this.addDep($,J.meta.chunk);return J});let _=!1;if($.expr.op==="num"&&!$.expr.meta?.rel)this.writeValue($.offset,$.expr.num,$.size),_=!0;else if($.expr.op===".move"){if($.expr.args.length!==1)throw new Error("bad .move");let J=$.expr.args[0];if(J.op==="num"&&J.meta?.offset!=null){let H=J.meta.offset-(J.meta.rel?0:J.meta.org),q=J.num+H,Q=this.linker.orig.slice(q,q+$.size);this.writeBytes($.offset,Uint8Array.from(Q)),_=!0}}if(_){if(this.subs.delete($)||this.selfSubs.delete($),!this.subs.size){if(this.linker.unresolvedChunks.delete(this))this.linker.insertResolved(this)}}}writeBytes($,W){if(this._data)this._data.subarray($,$+W.length).set(W);else if(this._offset!=null)this.linker.data.set(this._offset+$,W);else throw new Error("Impossible")}writeValue($,W,_){let J=_<<3;if(W!=null&&(W<-1<<J||W>=1<<J)){let q=["byte","word","farword","dword"][_-1];throw new Error(`Not a ${q}: $${W.toString(16)} at $${(this.org+$).toString(16)}`)}let H=new Uint8Array(_);for(let q=0;q<_;q++)H[q]=W&255,W>>=8;this.writeBytes($,H)}}function j6($,W,_){return $={...$},$.expr=O2($.expr,W,_),$}function O2($,W,_){if($={...$},$.meta)$.meta={...$.meta};if($.args)$.args=$.args.map((J)=>O2(J,W,_));if($.meta?.chunk!=null)$.meta.chunk+=W;if($.op==="sym"&&$.num!=null)$.num+=_;return $}function Y6($,W,_){if($={...$},$.expr)$.expr=O2($.expr,W,_);return $}class t${data=new L0;orig=new L0;exports=new Map;chunks=[];symbols=[];written=new l0;free=new l0;rawSegments=new Map;segments=new Map;resolvedChunks=[];unresolvedChunks=new Set;watches=[];placed=[];initialReport="";insertResolved($){I2(this.resolvedChunks,(W)=>W.size,$)}base($,W=0){this.data.set(W,$),this.orig.set(W,$)}readFile($){let W=this.chunks.length,_=this.symbols.length;for(let J of $.segments||[])this.addRawSegment(J);for(let J of $.chunks||[]){let H=new s$(this,this.chunks.length,J,W,_);this.chunks.push(H)}for(let J of $.symbols||[])this.symbols.push(Y6(J,W,_))}resolveLink($){if($.op===".orig"&&$.args?.length===1){let W=$.args[0],_=W.meta?.offset;if(_!=null){let J=this.orig.get(_+W.num);if(J!=null)return{op:"num",num:J}}}else if($.op==="num"&&$.meta?.chunk!=null){let W=$.meta,_=this.chunks[W.chunk];if(_.org!==W.org||_.segment?.bank!==W.bank||_.offset!==W.offset){let J={org:_.org,offset:_.offset,bank:_.segment?.bank};$=Z({...$,meta:{...W,...J}})}}return $}resolveExpr($){if($=Y0($,(_,J)=>{return this.resolveLink(Z(J(_)))}),$.op==="num"&&!$.meta?.rel)return $.num;let W=v($);throw new Error(`Unable to fully resolve expr${W}`)}link(){for(let[J,H]of this.rawSegments){let q=H[0];for(let Q=1;Q<H.length;Q++)q=d0.merge(q,H[Q]);this.segments.set(J,new a$(q))}for(let[J,H]of this.rawSegments){let q=this.segments.get(J);for(let Q of H){let G=Q.free;for(let[X,j]of G||[])this.free.add(X+q.delta,j+q.delta),this.data.splice(X+q.delta,j-X)}}for(let J of this.chunks)J.initialPlacement();if(i2)this.initialReport=`Initial:
${this.report(!0)}`;for(let J=0;J<this.symbols.length;J++){let H=this.symbols[J];if(!H.expr)throw new Error(`Symbol ${J} never resolved`);if(H.export!=null)this.exports.set(H.export,J)}for(let J of this.symbols)J.expr=this.resolveSymbols(J.expr);for(let J of this.chunks){for(let H of[...J.subs,...J.selfSubs])H.expr=this.resolveSymbols(H.expr);for(let H=0;H<J.asserts.length;H++)J.asserts[H]=this.resolveSymbols(J.asserts[H])}for(let J of this.chunks)J.resolveSubs(!0);let $=[...this.chunks];$.sort((J,H)=>H.size-J.size);for(let J of $)if(J.resolveSubs(),J.subs.size)this.unresolvedChunks.add(J);else this.insertResolved(J);let W=this.resolvedChunks.length+2*this.unresolvedChunks.size;while(W){let J=this.resolvedChunks.pop();if(J)this.placeChunk(J);else{let[q]=this.unresolvedChunks;for(let Q of q.deps){let G=this.chunks[Q];if(G.org==null)this.placeChunk(G)}}let H=this.resolvedChunks.length+2*this.unresolvedChunks.size;if(H===W)throw console.error(this.resolvedChunks,this.unresolvedChunks),new Error("Not making progress");W=H}let _=new L0;for(let[J,H]of this.segments)if(H.fill){let q=new Uint8Array(new ArrayBuffer(H.size));q.fill(H.fill),_.set(H.offset,q)}for(let J of this.chunks){for(let H of J.asserts){if(this.resolveExpr(H))continue;let Q=v(H);throw new Error(`Assertion failed${Q}`)}if(J.overlaps)continue;_.set(J.offset,Uint8Array.from(this.data.slice(J.offset,J.offset+J.size)))}if(i2)console.log(this.report(!0));return _}placeChunk($){if($.org!=null)return;if($.segments.length==0)this.rawSegments.forEach((J,H)=>{for(let q of J)if(q.default){$.segments=[H];break}});let W=$.size;if($.size<256&&!$.subs.size&&!$.selfSubs.size){let J=this.data.pattern($.data);for(let H of $.segments){let q=this.segments.get(H)??F0(`Segment not found with name: ${H}`),Q=q.offset,G=Q+q.size,X=J.search(Q,G);if(X<0)continue;$.place(X-q.delta,q),$.overlaps=!0;return}}for(let J of $.segments){let H=this.segments.get(J)??F0(`Segment not found with name: ${J}`),q=H.offset,Q=q+H.size,G,X=1/0;for(let[j,M]of this.free.tail(q)){if(j>=Q)break;let O=Math.min(M,Q)-j;if(O<W)continue;if(O<X)G=j,X=O}if(G!=null){$.place(G-H.delta,H);return}}if(i2)console.log(`Initial:
${this.initialReport}`);console.log(`After filling:
${this.report(!0)}`);let _=$.name?`${$.name} `:"";throw console.log(this.segments.get($.segments[0])),new Error(`Could not find space for ${W}-byte chunk ${_} in ${$.segments.join(", ")}`)}resolveSymbols($){return Y0($,(W,_)=>{while(W.op==="im"||W.op==="sym")if(W.op==="im"){let J=W.sym,H=this.exports.get(J);if(H==null){let q=v($);throw new Error(`Symbol never exported ${J}${q}`)}W=this.symbols[H].expr}else{if(W.num==null)throw new Error("Symbol not global");W=this.symbols[W.num].expr}return Z(_(W))})}addRawSegment($){let W=this.rawSegments.get($.name);if(!W)this.rawSegments.set($.name,W=[]);W.push($)}buildExports(){let $=new Map;for(let W of this.symbols){if(!W.export)continue;let _=Y0(W.expr,(q,Q)=>{return this.resolveLink(Z(Q(q)))});if(_.op!=="num")throw new Error(`never resolved: ${W.export}`);let J=_.num,H={value:J};if(_.meta?.offset!=null&&_.meta.org!=null)H.offset=_.meta.offset+J-_.meta.org;if(_.meta?.bank!=null)H.bank=_.meta.bank;$.set(W.export,H)}return $}report($=!1){let W="";for(let[_,J]of this.free)W+=`Free: ${_.toString(16)}..${J.toString(16)}: ${J-_} bytes
`;if($)for(let[_,J]of this.placed){let H=J.name??`Chunk ${J.index}`,q=J.offset+J.size;W+=`${_.toString(16).padStart(5,"0")} .. ${q.toString(16).padStart(5,"0")}: ${H} (${q-_} bytes)
`}return W}}var i2=!1,z6=!1,w6=!1;async function R6($,W,_,J,H){switch(W.action){case"code":{let q=new q2(J,H,_),Q=new $0(W.code,W.name,_);q.enter(Q);let G=new H2(q,$);await $.tokens(G);break}case"label":{$.label(W.label),$.export(W.label);break}case"byte":{$.byte(...W.bytes);break}case"word":{$.word(...W.words);break}case"org":{$.org(W.addr,W.name);break}case"reloc":{$.reloc(W.name);break}case"export":{$.export(W.name);break}case"segment":{$.segment(...W.name);break}case"assign":{$.assign(W.name,W.value);break}case"set":{$.set(W.name,W.value);break}case"free":$.free(W.size)}}async function Z9($,W,_,J,H){let q=typeof $==="string"?JSON.parse($):$,Q=typeof _==="string"?JSON.parse(_):_;async function G(A,B){return Promise.resolve(J(A,B))}async function X(A,B){return Promise.resolve(H(A,B))}let j=[];for(let A of q){let B=new _2(w0.P02);for(let k of A)await R6(B,k,Q,G,X);j.push(B)}let M=typeof W==="string"?new l().decode(W):W,O=new Q2;O.base(M,0);for(let A of j)O.read(A.module());if(O.link().apply(M),typeof W==="string")return new l().encode(M);return M}export{Z9 as compile};

//# debugId=9E4A881761952AE164756E2164756E21
//# sourceMappingURL=libassembler.js.map
