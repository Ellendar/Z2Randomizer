@page "/"
@inject Blazored.LocalStorage.ILocalStorageService localStorage

<PageTitle>Z2R Randomizer Online</PageTitle>

<div hidden="@HasRom">
    <h3>
        Select your Zelda 2 ROM to get started!
    </h3>

    <label>
        <InputFile OnChange="@LoadROMFile" />
    </label>
</div>

<div hidden="@(!HasRom)" class="container">
    <div class="row">
        <div class="col-sm">
            <label>
                Seed
                <input @bind="Seed" />
                <button @onclick="@NewSeed">New Seed</button>
            </label>
        </div>
        <div class="col-sm">
            <label>
                Flags
                <input @bind="Flags" />
            </label>
        </div>
        <div class="col-sm">
            <label>
                <button @onclick="@OnShowModalClick">Generate ROM</button>
            </label>
        </div>
    </div>
    <Tabs>
        <Tab Title="General" IsActive="true">
            <Content>
                <p class="mt-3">This is the placeholder content for the <b>General</b> tab.</p>
            </Content>
        </Tab>
    </Tabs>
</div>

<Modal @ref="modal" title="Generating ROM" IsVerticallyCentered="true" CloseOnEscape="false">
    <BodyTemplate>
        @GenerationProgress
    </BodyTemplate>
    <FooterTemplate>
        <Button Color="ButtonColor.Secondary" @onclick="OnHideModalClick">Cancel</Button>
        <Button Color="ButtonColor.Primary" disabled>Generating...</Button>
    </FooterTemplate>
</Modal>


@code {

    @using Z2Randomizer.Core
    @using Z2Randomizer.Core.Sidescroll
    @using System.Security.Cryptography

    @inject IJSRuntime JS
    @inject HttpClient Http
    @inject WebWorkerService webWorkerService
    @inject IRandomizerService randomizeService

    private string? Seed { get; set; }

    private string? Flags { get; set; }

    private WebWorker webWorker { get; set; }

    //private class ProgressRef { public string Progress { get; set; } }
    //private ProgressRef GenerationProgress = new ProgressRef();
    private string GenerationProgress { get; set; } = "";

    private RandomizerConfiguration config = new RandomizerConfiguration();

    //private CancellationTokenSource cancellation = new CancellationTokenSource();

    protected async Task NewSeed()
    {
        Seed = new Random().Next(1000000000).ToString();
    }

    protected async Task GenerateROM()
    {
        config = new RandomizerConfiguration(Flags);
        var palaceRoomsRaw = await Http.GetStringAsync("PalaceRooms.json");
        var palaceRooms = new PalaceRooms(palaceRoomsRaw, null);
        //var progress = new Progress<string>(val =>
        //{
        //    GenerationProgress = val;
        //    Console.WriteLine("progresss " + val);
        //    StateHasChanged();
        //});


        // Create worker.
        //var worker = await workerFactory.CreateAsync();

        // Create service reference. For most scenarios, it's safe (and best) to keep this
        // reference around somewhere to avoid the startup cost.
        //var service = await worker.CreateBackgroundServiceAsync<WebWorker>();


        //await service.RegisterEventListenerAsync(nameof(WebWorker.Progress),
        //    (object s, string eventInfo) =>
        //    {
        //        GenerationProgress.Progress = eventInfo;
        //        StateHasChanged();
        //    });



        // ...

        webWorker = await webWorkerService.GetWebWorker();

        // Call GetService<ServiceInterface> on a web worker to get a proxy for the service on the web worker.
        // GetService can only be called with Interface types
        var workerRandomizeService = webWorker.GetService<IRandomizerService>();


        // Reference that live outside of the current scope should not be passed into the expression.
        // To circumvent this, create a scope-local variable like this, and pass the local variable.
        //var localConfig = config;
        //var localRom = ROM;
        //var cancellationToken = cancellation.Token;

        var randomizer = new Hyrule(config, ROM, palaceRooms);
        var randomized = await workerRandomizeService.Randomize(config, ROM, palaceRoomsRaw, new Action<string>(s => {
            GenerationProgress = s;
            Console.WriteLine($"progress {s}");
            StateHasChanged();
            Task.Delay(1);
        }));
        //var randomized = await workerRandomizeService.Randomize(config, ROM, palaceRooms, new Action<string>(s => {
        //    GenerationProgress = s;
        //    StateHasChanged();
        //}), new Func<bool>(() => {
        //    return IsCancelled;
        //}));


        var fileName = "rom.nes";
        using var streamRef = new DotNetStreamReference(stream: new MemoryStream(randomized));
        await JS.InvokeVoidAsync("downloadFileFromStream", fileName, streamRef);
    }

    public bool HasRom { get => ROM != null; }
    public static byte[] GetBytes(Stream stream)
    {
        var bytes = new byte[stream.Length];
        stream.Seek(0, SeekOrigin.Begin);
        stream.ReadAsync(bytes, 0, bytes.Length);
        stream.Dispose();
        return bytes;
    }

    public byte[]? ROM;

    protected override async Task OnInitializedAsync()
    {
        Console.WriteLine("Attempting to load from local storage");
        await LoadROMFromLocalStorage();
    }

    protected async Task LoadROMFromLocalStorage()
    {
        string ROMencoded = await localStorage.GetItemAsync<string>("ROM");
        var ROMData = Convert.FromBase64String(ROMencoded);
        if (CheckROMHash(ROMData))
        {
            Console.WriteLine("Hash matches!");
            ROM = ROMData;
        }
        else
        {

            Console.WriteLine("Hash no matches!");
        }
    }

    public async Task LoadROMFile(InputFileChangeEventArgs e)
    {
        await using MemoryStream fs = new MemoryStream();
        await e.File.OpenReadStream(maxAllowedSize: 257 * 1024).CopyToAsync(fs);
        byte[] somBytes = GetBytes(fs);
        var base64String = Convert.ToBase64String(somBytes, 0, somBytes.Length);
        await localStorage.SetItemAsync("ROM", base64String);

        await LoadROMFromLocalStorage();
    }

    public static byte[] GOOD_ROM = new byte[]
    {
    0x35, 0x34, 0x89, 0xa5, 0x7f, 0x24, 0xa4, 0x29, 0x57, 0x2e, 0x76, 0xbd, 0x45, 0x5b, 0xc5, 0x1d, 0x82, 0x1f, 0x70, 0x36
    };

    public bool CheckROMHash(byte[] ROMData)
    {
        var sha1 = SHA1.Create();
        return GOOD_ROM.SequenceEqual(sha1.ComputeHash(ROMData));
    }

    public async void Clear()
    {
        //this will clear the local storage
        await localStorage.ClearAsync();
    }

    private Modal modal = default!;

    private async Task OnShowModalClick()
    {
        await modal.ShowAsync();
        await GenerateROM();
    }

    private async Task OnHideModalClick()
    {
        webWorker.Dispose();
        await modal.HideAsync();
    }
}
